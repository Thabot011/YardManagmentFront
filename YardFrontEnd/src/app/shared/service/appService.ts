/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    listCountry(body?: CountryRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listEmirate(body?: EmirateRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderType(body?: ProviderTypeRequest | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: UserRecord | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listUser(body?: UserRequest | undefined): Observable<SwaggerResponse<void>>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listCountry(body?: CountryRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Country/ListCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCountry(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processListCountry(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listEmirate(body?: EmirateRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Emirate/ListEmirate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListEmirate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListEmirate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processListEmirate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Provider/ListProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProvider(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processListProvider(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Provider/AddProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProvider(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processAddProvider(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Provider/EditProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProvider(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processEditProvider(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Provider/ActivateProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateProvider(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processActivateProvider(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProvider(body?: ProviderRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Provider/DeActivateProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateProvider(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateProvider(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderType(body?: ProviderTypeRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ProviderType/ListProviderType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProviderType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProviderType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processListProviderType(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: UserRecord | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listUser(body?: UserRequest | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/User/ListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUser(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processListUser(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export class CountryRecord implements ICountryRecord {
    id?: number;
    createdAt?: Date;
    isDeleted?: boolean;
    modifiedAt?: Date | undefined;
    name!: string;
    isActive?: boolean | undefined;
    code?: string | undefined;

    constructor(data?: ICountryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.modifiedAt = _data["ModifiedAt"] ? new Date(_data["ModifiedAt"].toString()) : <any>undefined;
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.code = _data["Code"];
        }
    }

    static fromJS(data: any, _mappings?: any): CountryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountryRecord>(data, _mappings, CountryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["ModifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["Code"] = this.code;
        return data; 
    }
}

export interface ICountryRecord {
    id?: number;
    createdAt?: Date;
    isDeleted?: boolean;
    modifiedAt?: Date | undefined;
    name: string;
    isActive?: boolean | undefined;
    code?: string | undefined;
}

export class MailSender implements IMailSender {

    constructor(data?: IMailSender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): MailSender {
        data = typeof data === 'object' ? data : {};
        return createInstance<MailSender>(data, _mappings, MailSender);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IMailSender {
}

export class CountryRequest implements ICountryRequest {
    countryRecord?: CountryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: ICountryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.countryRecord = data.countryRecord && !(<any>data.countryRecord).toJSON ? new CountryRecord(data.countryRecord) : <CountryRecord>this.countryRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.countryRecord = _data["CountryRecord"] ? CountryRecord.fromJS(_data["CountryRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["IsDesc"];
            this.orderByColumn = _data["OrderByColumn"];
            this.pageSize = _data["PageSize"];
            this.pageIndex = _data["PageIndex"];
            this.createdBy = _data["CreatedBy"];
            this.roleID = _data["RoleID"];
            this.languageId = _data["LanguageId"];
            this.yardId = _data["YardId"];
            this.baseUrl = _data["BaseUrl"];
            this.name = _data["Name"];
            this.mailSender = _data["MailSender"] ? MailSender.fromJS(_data["MailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CountryRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountryRequest>(data, _mappings, CountryRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CountryRecord"] = this.countryRecord ? this.countryRecord.toJSON() : <any>undefined;
        data["IsDesc"] = this.isDesc;
        data["OrderByColumn"] = this.orderByColumn;
        data["PageSize"] = this.pageSize;
        data["PageIndex"] = this.pageIndex;
        data["CreatedBy"] = this.createdBy;
        data["RoleID"] = this.roleID;
        data["LanguageId"] = this.languageId;
        data["YardId"] = this.yardId;
        data["BaseUrl"] = this.baseUrl;
        data["Name"] = this.name;
        data["MailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICountryRequest {
    countryRecord?: ICountryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class EmirateRecord implements IEmirateRecord {
    id?: number;
    name?: string | undefined;
    createAt?: Date;
    code?: string | undefined;
    isGcc?: boolean;
    countryId?: number | undefined;

    constructor(data?: IEmirateRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.createAt = _data["CreateAt"] ? new Date(_data["CreateAt"].toString()) : <any>undefined;
            this.code = _data["Code"];
            this.isGcc = _data["IsGcc"];
            this.countryId = _data["CountryId"];
        }
    }

    static fromJS(data: any, _mappings?: any): EmirateRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmirateRecord>(data, _mappings, EmirateRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["CreateAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["Code"] = this.code;
        data["IsGcc"] = this.isGcc;
        data["CountryId"] = this.countryId;
        return data; 
    }
}

export interface IEmirateRecord {
    id?: number;
    name?: string | undefined;
    createAt?: Date;
    code?: string | undefined;
    isGcc?: boolean;
    countryId?: number | undefined;
}

export class EmirateRequest implements IEmirateRequest {
    emirateRecord?: EmirateRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IEmirateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.emirateRecord = data.emirateRecord && !(<any>data.emirateRecord).toJSON ? new EmirateRecord(data.emirateRecord) : <EmirateRecord>this.emirateRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.emirateRecord = _data["EmirateRecord"] ? EmirateRecord.fromJS(_data["EmirateRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["IsDesc"];
            this.orderByColumn = _data["OrderByColumn"];
            this.pageSize = _data["PageSize"];
            this.pageIndex = _data["PageIndex"];
            this.createdBy = _data["CreatedBy"];
            this.roleID = _data["RoleID"];
            this.languageId = _data["LanguageId"];
            this.yardId = _data["YardId"];
            this.baseUrl = _data["BaseUrl"];
            this.name = _data["Name"];
            this.mailSender = _data["MailSender"] ? MailSender.fromJS(_data["MailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): EmirateRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmirateRequest>(data, _mappings, EmirateRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EmirateRecord"] = this.emirateRecord ? this.emirateRecord.toJSON() : <any>undefined;
        data["IsDesc"] = this.isDesc;
        data["OrderByColumn"] = this.orderByColumn;
        data["PageSize"] = this.pageSize;
        data["PageIndex"] = this.pageIndex;
        data["CreatedBy"] = this.createdBy;
        data["RoleID"] = this.roleID;
        data["LanguageId"] = this.languageId;
        data["YardId"] = this.yardId;
        data["BaseUrl"] = this.baseUrl;
        data["Name"] = this.name;
        data["MailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEmirateRequest {
    emirateRecord?: IEmirateRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ProviderRecord implements IProviderRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    createdAt?: Date;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isDeleted?: boolean;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    modifiedAt?: Date | undefined;

    constructor(data?: IProviderRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nameEn = _data["NameEn"];
            this.nameAr = _data["NameAr"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : <any>undefined;
            this.typeId = _data["TypeId"];
            this.emirateId = _data["EmirateId"];
            this.address = _data["Address"];
            this.email = _data["Email"];
            this.landline = _data["Landline"];
            this.mobile = _data["Mobile"];
            this.website = _data["Website"];
            this.trn = _data["Trn"];
            this.isDeleted = _data["IsDeleted"];
            this.isActive = _data["IsActive"];
            this.name = _data["Name"];
            this.emirateName = _data["EmirateName"];
            this.typeName = _data["TypeName"];
            this.modifiedAt = _data["ModifiedAt"] ? new Date(_data["ModifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderRecord>(data, _mappings, ProviderRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NameEn"] = this.nameEn;
        data["NameAr"] = this.nameAr;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["TypeId"] = this.typeId;
        data["EmirateId"] = this.emirateId;
        data["Address"] = this.address;
        data["Email"] = this.email;
        data["Landline"] = this.landline;
        data["Mobile"] = this.mobile;
        data["Website"] = this.website;
        data["Trn"] = this.trn;
        data["IsDeleted"] = this.isDeleted;
        data["IsActive"] = this.isActive;
        data["Name"] = this.name;
        data["EmirateName"] = this.emirateName;
        data["TypeName"] = this.typeName;
        data["ModifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IProviderRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    createdAt?: Date;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isDeleted?: boolean;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    modifiedAt?: Date | undefined;
}

export class ProviderRequest implements IProviderRequest {
    providerRecord?: ProviderRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IProviderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.providerRecord = data.providerRecord && !(<any>data.providerRecord).toJSON ? new ProviderRecord(data.providerRecord) : <ProviderRecord>this.providerRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerRecord = _data["ProviderRecord"] ? ProviderRecord.fromJS(_data["ProviderRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["IsDesc"];
            this.orderByColumn = _data["OrderByColumn"];
            this.pageSize = _data["PageSize"];
            this.pageIndex = _data["PageIndex"];
            this.createdBy = _data["CreatedBy"];
            this.roleID = _data["RoleID"];
            this.languageId = _data["LanguageId"];
            this.yardId = _data["YardId"];
            this.baseUrl = _data["BaseUrl"];
            this.name = _data["Name"];
            this.mailSender = _data["MailSender"] ? MailSender.fromJS(_data["MailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderRequest>(data, _mappings, ProviderRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProviderRecord"] = this.providerRecord ? this.providerRecord.toJSON() : <any>undefined;
        data["IsDesc"] = this.isDesc;
        data["OrderByColumn"] = this.orderByColumn;
        data["PageSize"] = this.pageSize;
        data["PageIndex"] = this.pageIndex;
        data["CreatedBy"] = this.createdBy;
        data["RoleID"] = this.roleID;
        data["LanguageId"] = this.languageId;
        data["YardId"] = this.yardId;
        data["BaseUrl"] = this.baseUrl;
        data["Name"] = this.name;
        data["MailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProviderRequest {
    providerRecord?: IProviderRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ProviderTypeRecord implements IProviderTypeRecord {
    id?: number;
    createdAt?: Date;
    isDeleted?: boolean;
    modifiedAt?: Date | undefined;
    name!: string;
    isActive?: boolean | undefined;

    constructor(data?: IProviderTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.modifiedAt = _data["ModifiedAt"] ? new Date(_data["ModifiedAt"].toString()) : <any>undefined;
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderTypeRecord>(data, _mappings, ProviderTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["ModifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        return data; 
    }
}

export interface IProviderTypeRecord {
    id?: number;
    createdAt?: Date;
    isDeleted?: boolean;
    modifiedAt?: Date | undefined;
    name: string;
    isActive?: boolean | undefined;
}

export class ProviderTypeRequest implements IProviderTypeRequest {
    providerTypeRecord?: ProviderTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IProviderTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.providerTypeRecord = data.providerTypeRecord && !(<any>data.providerTypeRecord).toJSON ? new ProviderTypeRecord(data.providerTypeRecord) : <ProviderTypeRecord>this.providerTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerTypeRecord = _data["ProviderTypeRecord"] ? ProviderTypeRecord.fromJS(_data["ProviderTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["IsDesc"];
            this.orderByColumn = _data["OrderByColumn"];
            this.pageSize = _data["PageSize"];
            this.pageIndex = _data["PageIndex"];
            this.createdBy = _data["CreatedBy"];
            this.roleID = _data["RoleID"];
            this.languageId = _data["LanguageId"];
            this.yardId = _data["YardId"];
            this.baseUrl = _data["BaseUrl"];
            this.name = _data["Name"];
            this.mailSender = _data["MailSender"] ? MailSender.fromJS(_data["MailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderTypeRequest>(data, _mappings, ProviderTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProviderTypeRecord"] = this.providerTypeRecord ? this.providerTypeRecord.toJSON() : <any>undefined;
        data["IsDesc"] = this.isDesc;
        data["OrderByColumn"] = this.orderByColumn;
        data["PageSize"] = this.pageSize;
        data["PageIndex"] = this.pageIndex;
        data["CreatedBy"] = this.createdBy;
        data["RoleID"] = this.roleID;
        data["LanguageId"] = this.languageId;
        data["YardId"] = this.yardId;
        data["BaseUrl"] = this.baseUrl;
        data["Name"] = this.name;
        data["MailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProviderTypeRequest {
    providerTypeRecord?: IProviderTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class UserRecord implements IUserRecord {
    id?: number;
    name!: string;
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;
    roleID!: number;
    roleName?: string | undefined;
    lastLoginDate?: Date;
    phoneNumber!: string;
    isLoggedIn?: boolean | undefined;
    yardId?: number;
    isActive?: boolean | undefined;

    constructor(data?: IUserRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.email = _data["Email"];
            this.password = _data["Password"];
            this.confirmPassword = _data["ConfirmPassword"];
            this.roleID = _data["RoleID"];
            this.roleName = _data["RoleName"];
            this.lastLoginDate = _data["LastLoginDate"] ? new Date(_data["LastLoginDate"].toString()) : <any>undefined;
            this.phoneNumber = _data["PhoneNumber"];
            this.isLoggedIn = _data["IsLoggedIn"];
            this.yardId = _data["YardId"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRecord>(data, _mappings, UserRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["ConfirmPassword"] = this.confirmPassword;
        data["RoleID"] = this.roleID;
        data["RoleName"] = this.roleName;
        data["LastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
        data["PhoneNumber"] = this.phoneNumber;
        data["IsLoggedIn"] = this.isLoggedIn;
        data["YardId"] = this.yardId;
        data["IsActive"] = this.isActive;
        return data; 
    }
}

export interface IUserRecord {
    id?: number;
    name: string;
    email: string;
    password: string;
    confirmPassword?: string | undefined;
    roleID: number;
    roleName?: string | undefined;
    lastLoginDate?: Date;
    phoneNumber: string;
    isLoggedIn?: boolean | undefined;
    yardId?: number;
    isActive?: boolean | undefined;
}

export class UserRequest implements IUserRequest {
    userRecord?: UserRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userRecord = data.userRecord && !(<any>data.userRecord).toJSON ? new UserRecord(data.userRecord) : <UserRecord>this.userRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userRecord = _data["UserRecord"] ? UserRecord.fromJS(_data["UserRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["IsDesc"];
            this.orderByColumn = _data["OrderByColumn"];
            this.pageSize = _data["PageSize"];
            this.pageIndex = _data["PageIndex"];
            this.createdBy = _data["CreatedBy"];
            this.roleID = _data["RoleID"];
            this.languageId = _data["LanguageId"];
            this.yardId = _data["YardId"];
            this.baseUrl = _data["BaseUrl"];
            this.name = _data["Name"];
            this.mailSender = _data["MailSender"] ? MailSender.fromJS(_data["MailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UserRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRequest>(data, _mappings, UserRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRecord"] = this.userRecord ? this.userRecord.toJSON() : <any>undefined;
        data["IsDesc"] = this.isDesc;
        data["OrderByColumn"] = this.orderByColumn;
        data["PageSize"] = this.pageSize;
        data["PageIndex"] = this.pageIndex;
        data["CreatedBy"] = this.createdBy;
        data["RoleID"] = this.roleID;
        data["LanguageId"] = this.languageId;
        data["YardId"] = this.yardId;
        data["BaseUrl"] = this.baseUrl;
        data["Name"] = this.name;
        data["MailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserRequest {
    userRecord?: IUserRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    yardId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}