/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiaryType(body?: BeneficiaryTypeRequest | undefined): Observable<BeneficiaryTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listCountry(body?: CountryRequest | undefined): Observable<CountryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listDocumentType(body?: DocumentTypeRequest | undefined): Observable<DocumentTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listEmirate(body?: EmirateRequest | undefined): Observable<EmirateResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listImageType(body?: ImageTypeRequest | undefined): Observable<ImageTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listMake(body?: MakeRequest | undefined): Observable<MakeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listModel(body?: ModelRequest | undefined): Observable<ModelResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listPlateType(body?: PlateTypeRequest | undefined): Observable<PlateTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderType(body?: ProviderTypeRequest | undefined): Observable<ProviderTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: UserRecord | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listUser(body?: UserRequest | undefined): Observable<UserResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse>;
    /**
     * @param id (optional) 
     * @param documentHash (optional) 
     * @param documentName (optional) 
     * @param documentType (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param createdAt (optional) 
     * @param documentTypeName (optional) 
     * @param docFile (optional) 
     * @param docUrl (optional) 
     * @return Success
     */
    testCDN(id?: number | undefined, documentHash?: string | null | undefined, documentName?: string | null | undefined, documentType?: number | undefined, title?: string | null | undefined, description?: string | null | undefined, createdAt?: Date | undefined, documentTypeName?: string | null | undefined, docFile?: FileParameter | null | undefined, docUrl?: string | null | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    completeVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveReviewedVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changeVehicleOwnership(body?: VehicleRequest | undefined): Observable<VehicleResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleAction(body?: VehicleActionRequest | undefined): Observable<VehicleActionResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleActionHistory(body?: VehicleActionHistoryRequest | undefined): Observable<VehicleActionHistoryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleDataStatus(body?: VehicleDataStatusRequest | undefined): Observable<VehicleDataStatusResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleOwnershipHistory(body?: VehicleOwnershipHistoryRequest | undefined): Observable<VehicleOwnershipHistoryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleStatus(body?: VehicleStatusRequest | undefined): Observable<VehicleStatusResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleType(body?: VehicleTypeRequest | undefined): Observable<VehicleTypeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    approveYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    rejectYard(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    approveYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    rejectYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listYardStatus(body?: YardStatusRequest | undefined): Observable<YardStatusResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    listZone(body?: ZoneRequest | undefined): Observable<ZoneResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addZone(body?: ZoneRequest | undefined): Observable<ZoneResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    editZone(body?: ZoneRequest | undefined): Observable<ZoneResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    activateZone(body?: ZoneRequest | undefined): Observable<ZoneResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateZone(body?: ZoneRequest | undefined): Observable<ZoneResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse> {
        let url_ = this.baseUrl + "/api/Beneficiary/ListBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListBeneficiary(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListBeneficiary(response: HttpResponseBase): Observable<BeneficiaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse> {
        let url_ = this.baseUrl + "/api/Beneficiary/AddBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBeneficiary(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddBeneficiary(response: HttpResponseBase): Observable<BeneficiaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse> {
        let url_ = this.baseUrl + "/api/Beneficiary/EditBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditBeneficiary(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditBeneficiary(response: HttpResponseBase): Observable<BeneficiaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse> {
        let url_ = this.baseUrl + "/api/Beneficiary/ActivateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateBeneficiary(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateBeneficiary(body?: BeneficiaryRequest | undefined): Observable<BeneficiaryResponse> {
        let url_ = this.baseUrl + "/api/Beneficiary/DeActivateBeneficiary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateBeneficiary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateBeneficiary(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateBeneficiary(response: HttpResponseBase): Observable<BeneficiaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryContact/ListBeneficiaryContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListBeneficiaryContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListBeneficiaryContact(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListBeneficiaryContact(response: HttpResponseBase): Observable<BeneficiaryContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryContact/AddBeneficiaryContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBeneficiaryContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBeneficiaryContact(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddBeneficiaryContact(response: HttpResponseBase): Observable<BeneficiaryContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryContact/EditBeneficiaryContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditBeneficiaryContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditBeneficiaryContact(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditBeneficiaryContact(response: HttpResponseBase): Observable<BeneficiaryContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryContact/ActivateBeneficiaryContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateBeneficiaryContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateBeneficiaryContact(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateBeneficiaryContact(response: HttpResponseBase): Observable<BeneficiaryContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateBeneficiaryContact(body?: BeneficiaryContactRequest | undefined): Observable<BeneficiaryContactResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryContact/DeActivateBeneficiaryContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateBeneficiaryContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateBeneficiaryContact(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateBeneficiaryContact(response: HttpResponseBase): Observable<BeneficiaryContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listBeneficiaryType(body?: BeneficiaryTypeRequest | undefined): Observable<BeneficiaryTypeResponse> {
        let url_ = this.baseUrl + "/api/BeneficiaryType/ListBeneficiaryType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListBeneficiaryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListBeneficiaryType(<any>response_);
                } catch (e) {
                    return <Observable<BeneficiaryTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeneficiaryTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListBeneficiaryType(response: HttpResponseBase): Observable<BeneficiaryTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = BeneficiaryTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeneficiaryTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listCountry(body?: CountryRequest | undefined): Observable<CountryResponse> {
        let url_ = this.baseUrl + "/api/Country/ListCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListCountry(response: HttpResponseBase): Observable<CountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CountryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listDocumentType(body?: DocumentTypeRequest | undefined): Observable<DocumentTypeResponse> {
        let url_ = this.baseUrl + "/api/DocumentType/ListDocumentType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListDocumentType(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListDocumentType(response: HttpResponseBase): Observable<DocumentTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = DocumentTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listEmirate(body?: EmirateRequest | undefined): Observable<EmirateResponse> {
        let url_ = this.baseUrl + "/api/Emirate/ListEmirate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListEmirate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListEmirate(<any>response_);
                } catch (e) {
                    return <Observable<EmirateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmirateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListEmirate(response: HttpResponseBase): Observable<EmirateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = EmirateResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmirateResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listImageType(body?: ImageTypeRequest | undefined): Observable<ImageTypeResponse> {
        let url_ = this.baseUrl + "/api/ImageType/ListImageType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListImageType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListImageType(<any>response_);
                } catch (e) {
                    return <Observable<ImageTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImageTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListImageType(response: HttpResponseBase): Observable<ImageTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ImageTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImageTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listMake(body?: MakeRequest | undefined): Observable<MakeResponse> {
        let url_ = this.baseUrl + "/api/Make/ListMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMake(<any>response_);
                } catch (e) {
                    return <Observable<MakeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MakeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListMake(response: HttpResponseBase): Observable<MakeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MakeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MakeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listModel(body?: ModelRequest | undefined): Observable<ModelResponse> {
        let url_ = this.baseUrl + "/api/Model/ListModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListModel(<any>response_);
                } catch (e) {
                    return <Observable<ModelResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListModel(response: HttpResponseBase): Observable<ModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ModelResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listPlateType(body?: PlateTypeRequest | undefined): Observable<PlateTypeResponse> {
        let url_ = this.baseUrl + "/api/PlateType/ListPlateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListPlateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListPlateType(<any>response_);
                } catch (e) {
                    return <Observable<PlateTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlateTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListPlateType(response: HttpResponseBase): Observable<PlateTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = PlateTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlateTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse> {
        let url_ = this.baseUrl + "/api/Provider/ListProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProvider(<any>response_);
                } catch (e) {
                    return <Observable<ProviderResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListProvider(response: HttpResponseBase): Observable<ProviderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse> {
        let url_ = this.baseUrl + "/api/Provider/AddProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProvider(<any>response_);
                } catch (e) {
                    return <Observable<ProviderResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddProvider(response: HttpResponseBase): Observable<ProviderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse> {
        let url_ = this.baseUrl + "/api/Provider/EditProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProvider(<any>response_);
                } catch (e) {
                    return <Observable<ProviderResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditProvider(response: HttpResponseBase): Observable<ProviderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse> {
        let url_ = this.baseUrl + "/api/Provider/ActivateProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateProvider(<any>response_);
                } catch (e) {
                    return <Observable<ProviderResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateProvider(response: HttpResponseBase): Observable<ProviderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProvider(body?: ProviderRequest | undefined): Observable<ProviderResponse> {
        let url_ = this.baseUrl + "/api/Provider/DeActivateProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateProvider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateProvider(<any>response_);
                } catch (e) {
                    return <Observable<ProviderResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateProvider(response: HttpResponseBase): Observable<ProviderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse> {
        let url_ = this.baseUrl + "/api/ProviderContact/ListProviderContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProviderContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProviderContact(<any>response_);
                } catch (e) {
                    return <Observable<ProviderContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListProviderContact(response: HttpResponseBase): Observable<ProviderContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse> {
        let url_ = this.baseUrl + "/api/ProviderContact/AddProviderContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProviderContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProviderContact(<any>response_);
                } catch (e) {
                    return <Observable<ProviderContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddProviderContact(response: HttpResponseBase): Observable<ProviderContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse> {
        let url_ = this.baseUrl + "/api/ProviderContact/EditProviderContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProviderContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProviderContact(<any>response_);
                } catch (e) {
                    return <Observable<ProviderContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditProviderContact(response: HttpResponseBase): Observable<ProviderContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse> {
        let url_ = this.baseUrl + "/api/ProviderContact/ActivateProviderContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateProviderContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateProviderContact(<any>response_);
                } catch (e) {
                    return <Observable<ProviderContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateProviderContact(response: HttpResponseBase): Observable<ProviderContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateProviderContact(body?: ProviderContactRequest | undefined): Observable<ProviderContactResponse> {
        let url_ = this.baseUrl + "/api/ProviderContact/DeActivateProviderContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateProviderContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateProviderContact(<any>response_);
                } catch (e) {
                    return <Observable<ProviderContactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderContactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateProviderContact(response: HttpResponseBase): Observable<ProviderContactResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderContactResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listProviderType(body?: ProviderTypeRequest | undefined): Observable<ProviderTypeResponse> {
        let url_ = this.baseUrl + "/api/ProviderType/ListProviderType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProviderType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProviderType(<any>response_);
                } catch (e) {
                    return <Observable<ProviderTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListProviderType(response: HttpResponseBase): Observable<ProviderTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProviderTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: UserRecord | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listUser(body?: UserRequest | undefined): Observable<UserResponse> {
        let url_ = this.baseUrl + "/api/User/ListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUser(<any>response_);
                } catch (e) {
                    return <Observable<UserResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListUser(response: HttpResponseBase): Observable<UserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UserResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/ListVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicle(<any>response_);
                } catch (e) {
                    return <Observable<VehicleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicle(response: HttpResponseBase): Observable<VehicleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param documentHash (optional) 
     * @param documentName (optional) 
     * @param documentType (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param createdAt (optional) 
     * @param documentTypeName (optional) 
     * @param docFile (optional) 
     * @param docUrl (optional) 
     * @return Success
     */
    testCDN(id?: number | undefined, documentHash?: string | null | undefined, documentName?: string | null | undefined, documentType?: number | undefined, title?: string | null | undefined, description?: string | null | undefined, createdAt?: Date | undefined, documentTypeName?: string | null | undefined, docFile?: FileParameter | null | undefined, docUrl?: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Vehicle/TestCDN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (documentHash !== null && documentHash !== undefined)
            content_.append("DocumentHash", documentHash.toString());
        if (documentName !== null && documentName !== undefined)
            content_.append("DocumentName", documentName.toString());
        if (documentType === null || documentType === undefined)
            throw new Error("The parameter 'documentType' cannot be null.");
        else
            content_.append("DocumentType", documentType.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (createdAt === null || createdAt === undefined)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else
            content_.append("CreatedAt", createdAt.toJSON());
        if (documentTypeName !== null && documentTypeName !== undefined)
            content_.append("DocumentTypeName", documentTypeName.toString());
        if (docFile !== null && docFile !== undefined)
            content_.append("DocFile", docFile.data, docFile.fileName ? docFile.fileName : "DocFile");
        if (docUrl !== null && docUrl !== undefined)
            content_.append("DocUrl", docUrl.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCDN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCDN(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTestCDN(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/CompleteVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteVehicle(<any>response_);
                } catch (e) {
                    return <Observable<VehicleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteVehicle(response: HttpResponseBase): Observable<VehicleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveReviewedVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/SaveReviewedVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReviewedVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReviewedVehicle(<any>response_);
                } catch (e) {
                    return <Observable<VehicleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSaveReviewedVehicle(response: HttpResponseBase): Observable<VehicleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editVehicle(body?: VehicleRequest | undefined): Observable<VehicleResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/EditVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditVehicle(<any>response_);
                } catch (e) {
                    return <Observable<VehicleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditVehicle(response: HttpResponseBase): Observable<VehicleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeVehicleOwnership(body?: VehicleRequest | undefined): Observable<VehicleResponse> {
        let url_ = this.baseUrl + "/api/Vehicle/ChangeVehicleOwnership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeVehicleOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeVehicleOwnership(<any>response_);
                } catch (e) {
                    return <Observable<VehicleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangeVehicleOwnership(response: HttpResponseBase): Observable<VehicleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleAction(body?: VehicleActionRequest | undefined): Observable<VehicleActionResponse> {
        let url_ = this.baseUrl + "/api/VehicleAction/ListVehicleAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleAction(<any>response_);
                } catch (e) {
                    return <Observable<VehicleActionResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleActionResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleAction(response: HttpResponseBase): Observable<VehicleActionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleActionResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleActionResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleActionHistory(body?: VehicleActionHistoryRequest | undefined): Observable<VehicleActionHistoryResponse> {
        let url_ = this.baseUrl + "/api/VehicleActionHistory/ListVehicleActionHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleActionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleActionHistory(<any>response_);
                } catch (e) {
                    return <Observable<VehicleActionHistoryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleActionHistoryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleActionHistory(response: HttpResponseBase): Observable<VehicleActionHistoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleActionHistoryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleActionHistoryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleDataStatus(body?: VehicleDataStatusRequest | undefined): Observable<VehicleDataStatusResponse> {
        let url_ = this.baseUrl + "/api/VehicleDataStatus/ListVehicleDataStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleDataStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleDataStatus(<any>response_);
                } catch (e) {
                    return <Observable<VehicleDataStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleDataStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleDataStatus(response: HttpResponseBase): Observable<VehicleDataStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleDataStatusResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleDataStatusResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleOwnershipHistory(body?: VehicleOwnershipHistoryRequest | undefined): Observable<VehicleOwnershipHistoryResponse> {
        let url_ = this.baseUrl + "/api/VehicleOwnershipHistory/ListVehicleOwnershipHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleOwnershipHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleOwnershipHistory(<any>response_);
                } catch (e) {
                    return <Observable<VehicleOwnershipHistoryResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleOwnershipHistoryResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleOwnershipHistory(response: HttpResponseBase): Observable<VehicleOwnershipHistoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleOwnershipHistoryResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleOwnershipHistoryResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleStatus(body?: VehicleStatusRequest | undefined): Observable<VehicleStatusResponse> {
        let url_ = this.baseUrl + "/api/VehicleStatus/ListVehicleStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleStatus(<any>response_);
                } catch (e) {
                    return <Observable<VehicleStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleStatus(response: HttpResponseBase): Observable<VehicleStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleStatusResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleStatusResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listVehicleType(body?: VehicleTypeRequest | undefined): Observable<VehicleTypeResponse> {
        let url_ = this.baseUrl + "/api/VehicleType/ListVehicleType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVehicleType(<any>response_);
                } catch (e) {
                    return <Observable<VehicleTypeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleTypeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListVehicleType(response: HttpResponseBase): Observable<VehicleTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VehicleTypeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleTypeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/ListYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/AddYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/EditYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/ActivateYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/DeActivateYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/ApproveYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectYard(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/RejectYard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectYard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectYard(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRejectYard(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/ListYardToUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListYardToUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListYardToUpdate(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListYardToUpdate(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/ApproveYardToUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveYardToUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveYardToUpdate(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveYardToUpdate(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectYardToUpdate(body?: YardRequest | undefined): Observable<YardResponse> {
        let url_ = this.baseUrl + "/api/Yard/RejectYardToUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectYardToUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectYardToUpdate(<any>response_);
                } catch (e) {
                    return <Observable<YardResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRejectYardToUpdate(response: HttpResponseBase): Observable<YardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse> {
        let url_ = this.baseUrl + "/api/YardEmployee/ListYardEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListYardEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListYardEmployee(<any>response_);
                } catch (e) {
                    return <Observable<YardEmployeeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardEmployeeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListYardEmployee(response: HttpResponseBase): Observable<YardEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardEmployeeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardEmployeeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse> {
        let url_ = this.baseUrl + "/api/YardEmployee/AddYardEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddYardEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddYardEmployee(<any>response_);
                } catch (e) {
                    return <Observable<YardEmployeeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardEmployeeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddYardEmployee(response: HttpResponseBase): Observable<YardEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardEmployeeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardEmployeeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse> {
        let url_ = this.baseUrl + "/api/YardEmployee/EditYardEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditYardEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditYardEmployee(<any>response_);
                } catch (e) {
                    return <Observable<YardEmployeeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardEmployeeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditYardEmployee(response: HttpResponseBase): Observable<YardEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardEmployeeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardEmployeeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse> {
        let url_ = this.baseUrl + "/api/YardEmployee/ActivateYardEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateYardEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateYardEmployee(<any>response_);
                } catch (e) {
                    return <Observable<YardEmployeeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardEmployeeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateYardEmployee(response: HttpResponseBase): Observable<YardEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardEmployeeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardEmployeeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateYardEmployee(body?: YardEmployeeRequest | undefined): Observable<YardEmployeeResponse> {
        let url_ = this.baseUrl + "/api/YardEmployee/DeActivateYardEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateYardEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateYardEmployee(<any>response_);
                } catch (e) {
                    return <Observable<YardEmployeeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardEmployeeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateYardEmployee(response: HttpResponseBase): Observable<YardEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardEmployeeResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardEmployeeResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listYardStatus(body?: YardStatusRequest | undefined): Observable<YardStatusResponse> {
        let url_ = this.baseUrl + "/api/YardStatus/ListYardStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListYardStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListYardStatus(<any>response_);
                } catch (e) {
                    return <Observable<YardStatusResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YardStatusResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListYardStatus(response: HttpResponseBase): Observable<YardStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = YardStatusResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YardStatusResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listZone(body?: ZoneRequest | undefined): Observable<ZoneResponse> {
        let url_ = this.baseUrl + "/api/Zone/ListZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListZone(response: HttpResponseBase): Observable<ZoneResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ZoneResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addZone(body?: ZoneRequest | undefined): Observable<ZoneResponse> {
        let url_ = this.baseUrl + "/api/Zone/AddZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddZone(response: HttpResponseBase): Observable<ZoneResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ZoneResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editZone(body?: ZoneRequest | undefined): Observable<ZoneResponse> {
        let url_ = this.baseUrl + "/api/Zone/EditZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEditZone(response: HttpResponseBase): Observable<ZoneResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ZoneResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateZone(body?: ZoneRequest | undefined): Observable<ZoneResponse> {
        let url_ = this.baseUrl + "/api/Zone/ActivateZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneResponse>><any>_observableThrow(response_);
        }));
    }

    protected processActivateZone(response: HttpResponseBase): Observable<ZoneResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ZoneResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivateZone(body?: ZoneRequest | undefined): Observable<ZoneResponse> {
        let url_ = this.baseUrl + "/api/Zone/DeActivateZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivateZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivateZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivateZone(response: HttpResponseBase): Observable<ZoneResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ZoneResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneResponse>(<any>null);
    }
}

export class BeneficiaryRecord implements IBeneficiaryRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;

    constructor(data?: IBeneficiaryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameEn = _data["nameEn"];
            this.nameAr = _data["nameAr"];
            this.typeId = _data["typeId"];
            this.emirateId = _data["emirateId"];
            this.address = _data["address"];
            this.email = _data["email"];
            this.landline = _data["landline"];
            this.mobile = _data["mobile"];
            this.website = _data["website"];
            this.trn = _data["trn"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.emirateName = _data["emirateName"];
            this.typeName = _data["typeName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryRecord>(data, _mappings, BeneficiaryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameEn"] = this.nameEn;
        data["nameAr"] = this.nameAr;
        data["typeId"] = this.typeId;
        data["emirateId"] = this.emirateId;
        data["address"] = this.address;
        data["email"] = this.email;
        data["landline"] = this.landline;
        data["mobile"] = this.mobile;
        data["website"] = this.website;
        data["trn"] = this.trn;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["emirateName"] = this.emirateName;
        data["typeName"] = this.typeName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data; 
    }

    clone(): BeneficiaryRecord {
        const json = this.toJSON();
        let result = new BeneficiaryRecord();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
}

export class MailSender implements IMailSender {

    constructor(data?: IMailSender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): MailSender {
        data = typeof data === 'object' ? data : {};
        return createInstance<MailSender>(data, _mappings, MailSender);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): MailSender {
        const json = this.toJSON();
        let result = new MailSender();
        result.init(json);
        return result;
    }
}

export interface IMailSender {
}

export class BeneficiaryRequest implements IBeneficiaryRequest {
    beneficiaryRecord?: BeneficiaryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IBeneficiaryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.beneficiaryRecord = data.beneficiaryRecord && !(<any>data.beneficiaryRecord).toJSON ? new BeneficiaryRecord(data.beneficiaryRecord) : <BeneficiaryRecord>this.beneficiaryRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.beneficiaryRecord = _data["beneficiaryRecord"] ? BeneficiaryRecord.fromJS(_data["beneficiaryRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryRequest>(data, _mappings, BeneficiaryRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryRecord"] = this.beneficiaryRecord ? this.beneficiaryRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BeneficiaryRequest {
        const json = this.toJSON();
        let result = new BeneficiaryRequest();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryRequest {
    beneficiaryRecord?: IBeneficiaryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class BeneficiaryResponse implements IBeneficiaryResponse {
    data?: BeneficiaryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IBeneficiaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new BeneficiaryRecord(item) : <BeneficiaryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(BeneficiaryRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryResponse>(data, _mappings, BeneficiaryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BeneficiaryResponse {
        const json = this.toJSON();
        let result = new BeneficiaryResponse();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryResponse {
    data?: IBeneficiaryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class BeneficiaryContactRecord implements IBeneficiaryContactRecord {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    beneficiaryId?: number;
    beneficiaryName?: string | undefined;

    constructor(data?: IBeneficiaryContactRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.landline = _data["landline"];
            this.isActive = _data["isActive"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiaryName = _data["beneficiaryName"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryContactRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryContactRecord>(data, _mappings, BeneficiaryContactRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["landline"] = this.landline;
        data["isActive"] = this.isActive;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiaryName"] = this.beneficiaryName;
        return data; 
    }

    clone(): BeneficiaryContactRecord {
        const json = this.toJSON();
        let result = new BeneficiaryContactRecord();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryContactRecord {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    beneficiaryId?: number;
    beneficiaryName?: string | undefined;
}

export class BeneficiaryContactRequest implements IBeneficiaryContactRequest {
    beneficiaryContactRecord?: BeneficiaryContactRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IBeneficiaryContactRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.beneficiaryContactRecord = data.beneficiaryContactRecord && !(<any>data.beneficiaryContactRecord).toJSON ? new BeneficiaryContactRecord(data.beneficiaryContactRecord) : <BeneficiaryContactRecord>this.beneficiaryContactRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.beneficiaryContactRecord = _data["beneficiaryContactRecord"] ? BeneficiaryContactRecord.fromJS(_data["beneficiaryContactRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryContactRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryContactRequest>(data, _mappings, BeneficiaryContactRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryContactRecord"] = this.beneficiaryContactRecord ? this.beneficiaryContactRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BeneficiaryContactRequest {
        const json = this.toJSON();
        let result = new BeneficiaryContactRequest();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryContactRequest {
    beneficiaryContactRecord?: IBeneficiaryContactRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class BeneficiaryContactResponse implements IBeneficiaryContactResponse {
    data?: BeneficiaryContactRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IBeneficiaryContactResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new BeneficiaryContactRecord(item) : <BeneficiaryContactRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(BeneficiaryContactRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryContactResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryContactResponse>(data, _mappings, BeneficiaryContactResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BeneficiaryContactResponse {
        const json = this.toJSON();
        let result = new BeneficiaryContactResponse();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryContactResponse {
    data?: IBeneficiaryContactRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class BeneficiaryTypeRecord implements IBeneficiaryTypeRecord {
    id?: number;
    name!: string;
    isActive?: boolean | undefined;

    constructor(data?: IBeneficiaryTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryTypeRecord>(data, _mappings, BeneficiaryTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): BeneficiaryTypeRecord {
        const json = this.toJSON();
        let result = new BeneficiaryTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryTypeRecord {
    id?: number;
    name: string;
    isActive?: boolean | undefined;
}

export class BeneficiaryTypeRequest implements IBeneficiaryTypeRequest {
    beneficiaryTypeRecord?: BeneficiaryTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IBeneficiaryTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.beneficiaryTypeRecord = data.beneficiaryTypeRecord && !(<any>data.beneficiaryTypeRecord).toJSON ? new BeneficiaryTypeRecord(data.beneficiaryTypeRecord) : <BeneficiaryTypeRecord>this.beneficiaryTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.beneficiaryTypeRecord = _data["beneficiaryTypeRecord"] ? BeneficiaryTypeRecord.fromJS(_data["beneficiaryTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryTypeRequest>(data, _mappings, BeneficiaryTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryTypeRecord"] = this.beneficiaryTypeRecord ? this.beneficiaryTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BeneficiaryTypeRequest {
        const json = this.toJSON();
        let result = new BeneficiaryTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryTypeRequest {
    beneficiaryTypeRecord?: IBeneficiaryTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class BeneficiaryTypeResponse implements IBeneficiaryTypeResponse {
    data?: BeneficiaryTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IBeneficiaryTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new BeneficiaryTypeRecord(item) : <BeneficiaryTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(BeneficiaryTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): BeneficiaryTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<BeneficiaryTypeResponse>(data, _mappings, BeneficiaryTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BeneficiaryTypeResponse {
        const json = this.toJSON();
        let result = new BeneficiaryTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IBeneficiaryTypeResponse {
    data?: IBeneficiaryTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class CountryRecord implements ICountryRecord {
    id?: number;
    name!: string;
    isActive?: boolean | undefined;
    code?: string | undefined;

    constructor(data?: ICountryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any, _mappings?: any): CountryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountryRecord>(data, _mappings, CountryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        return data; 
    }

    clone(): CountryRecord {
        const json = this.toJSON();
        let result = new CountryRecord();
        result.init(json);
        return result;
    }
}

export interface ICountryRecord {
    id?: number;
    name: string;
    isActive?: boolean | undefined;
    code?: string | undefined;
}

export class CountryRequest implements ICountryRequest {
    countryRecord?: CountryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: ICountryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.countryRecord = data.countryRecord && !(<any>data.countryRecord).toJSON ? new CountryRecord(data.countryRecord) : <CountryRecord>this.countryRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.countryRecord = _data["countryRecord"] ? CountryRecord.fromJS(_data["countryRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CountryRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountryRequest>(data, _mappings, CountryRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryRecord"] = this.countryRecord ? this.countryRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CountryRequest {
        const json = this.toJSON();
        let result = new CountryRequest();
        result.init(json);
        return result;
    }
}

export interface ICountryRequest {
    countryRecord?: ICountryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class CountryResponse implements ICountryResponse {
    data?: CountryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: ICountryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CountryRecord(item) : <CountryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(CountryRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): CountryResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<CountryResponse>(data, _mappings, CountryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CountryResponse {
        const json = this.toJSON();
        let result = new CountryResponse();
        result.init(json);
        return result;
    }
}

export interface ICountryResponse {
    data?: ICountryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class DocumentTypeRecord implements IDocumentTypeRecord {
    id?: number;
    name?: string | undefined;

    constructor(data?: IDocumentTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentTypeRecord>(data, _mappings, DocumentTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): DocumentTypeRecord {
        const json = this.toJSON();
        let result = new DocumentTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeRecord {
    id?: number;
    name?: string | undefined;
}

export class DocumentTypeRequest implements IDocumentTypeRequest {
    documentTypeRecord?: DocumentTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IDocumentTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.documentTypeRecord = data.documentTypeRecord && !(<any>data.documentTypeRecord).toJSON ? new DocumentTypeRecord(data.documentTypeRecord) : <DocumentTypeRecord>this.documentTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.documentTypeRecord = _data["documentTypeRecord"] ? DocumentTypeRecord.fromJS(_data["documentTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentTypeRequest>(data, _mappings, DocumentTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentTypeRecord"] = this.documentTypeRecord ? this.documentTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DocumentTypeRequest {
        const json = this.toJSON();
        let result = new DocumentTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeRequest {
    documentTypeRecord?: IDocumentTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class DocumentTypeResponse implements IDocumentTypeResponse {
    data?: DocumentTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IDocumentTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new DocumentTypeRecord(item) : <DocumentTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(DocumentTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentTypeResponse>(data, _mappings, DocumentTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DocumentTypeResponse {
        const json = this.toJSON();
        let result = new DocumentTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeResponse {
    data?: IDocumentTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class EmirateRecord implements IEmirateRecord {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    isGcc?: boolean;
    countryId?: number | undefined;

    constructor(data?: IEmirateRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isGcc = _data["isGcc"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any, _mappings?: any): EmirateRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmirateRecord>(data, _mappings, EmirateRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isGcc"] = this.isGcc;
        data["countryId"] = this.countryId;
        return data; 
    }

    clone(): EmirateRecord {
        const json = this.toJSON();
        let result = new EmirateRecord();
        result.init(json);
        return result;
    }
}

export interface IEmirateRecord {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    isGcc?: boolean;
    countryId?: number | undefined;
}

export class EmirateRequest implements IEmirateRequest {
    emirateRecord?: EmirateRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IEmirateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.emirateRecord = data.emirateRecord && !(<any>data.emirateRecord).toJSON ? new EmirateRecord(data.emirateRecord) : <EmirateRecord>this.emirateRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.emirateRecord = _data["emirateRecord"] ? EmirateRecord.fromJS(_data["emirateRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): EmirateRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmirateRequest>(data, _mappings, EmirateRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emirateRecord"] = this.emirateRecord ? this.emirateRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EmirateRequest {
        const json = this.toJSON();
        let result = new EmirateRequest();
        result.init(json);
        return result;
    }
}

export interface IEmirateRequest {
    emirateRecord?: IEmirateRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class EmirateResponse implements IEmirateResponse {
    data?: EmirateRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IEmirateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new EmirateRecord(item) : <EmirateRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(EmirateRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): EmirateResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmirateResponse>(data, _mappings, EmirateResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmirateResponse {
        const json = this.toJSON();
        let result = new EmirateResponse();
        result.init(json);
        return result;
    }
}

export interface IEmirateResponse {
    data?: IEmirateRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ImageTypeRecord implements IImageTypeRecord {
    id?: number;
    name?: string | undefined;

    constructor(data?: IImageTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): ImageTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ImageTypeRecord>(data, _mappings, ImageTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ImageTypeRecord {
        const json = this.toJSON();
        let result = new ImageTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IImageTypeRecord {
    id?: number;
    name?: string | undefined;
}

export class ImageTypeRequest implements IImageTypeRequest {
    imageTypeRecord?: ImageTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IImageTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.imageTypeRecord = data.imageTypeRecord && !(<any>data.imageTypeRecord).toJSON ? new ImageTypeRecord(data.imageTypeRecord) : <ImageTypeRecord>this.imageTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.imageTypeRecord = _data["imageTypeRecord"] ? ImageTypeRecord.fromJS(_data["imageTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ImageTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ImageTypeRequest>(data, _mappings, ImageTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageTypeRecord"] = this.imageTypeRecord ? this.imageTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ImageTypeRequest {
        const json = this.toJSON();
        let result = new ImageTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IImageTypeRequest {
    imageTypeRecord?: IImageTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ImageTypeResponse implements IImageTypeResponse {
    data?: ImageTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IImageTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ImageTypeRecord(item) : <ImageTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ImageTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ImageTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ImageTypeResponse>(data, _mappings, ImageTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ImageTypeResponse {
        const json = this.toJSON();
        let result = new ImageTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IImageTypeResponse {
    data?: IImageTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class MakeRecord implements IMakeRecord {
    id?: number;
    name?: string | undefined;

    constructor(data?: IMakeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): MakeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<MakeRecord>(data, _mappings, MakeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): MakeRecord {
        const json = this.toJSON();
        let result = new MakeRecord();
        result.init(json);
        return result;
    }
}

export interface IMakeRecord {
    id?: number;
    name?: string | undefined;
}

export class MakeRequest implements IMakeRequest {
    makeRecord?: MakeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IMakeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.makeRecord = data.makeRecord && !(<any>data.makeRecord).toJSON ? new MakeRecord(data.makeRecord) : <MakeRecord>this.makeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.makeRecord = _data["makeRecord"] ? MakeRecord.fromJS(_data["makeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): MakeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<MakeRequest>(data, _mappings, MakeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["makeRecord"] = this.makeRecord ? this.makeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): MakeRequest {
        const json = this.toJSON();
        let result = new MakeRequest();
        result.init(json);
        return result;
    }
}

export interface IMakeRequest {
    makeRecord?: IMakeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class MakeResponse implements IMakeResponse {
    data?: MakeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IMakeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new MakeRecord(item) : <MakeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(MakeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): MakeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<MakeResponse>(data, _mappings, MakeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MakeResponse {
        const json = this.toJSON();
        let result = new MakeResponse();
        result.init(json);
        return result;
    }
}

export interface IMakeResponse {
    data?: IMakeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ModelRecord implements IModelRecord {
    id?: number;
    name?: string | undefined;
    makeId?: number | undefined;
    makeName?: string | undefined;

    constructor(data?: IModelRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.makeId = _data["makeId"];
            this.makeName = _data["makeName"];
        }
    }

    static fromJS(data: any, _mappings?: any): ModelRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModelRecord>(data, _mappings, ModelRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["makeId"] = this.makeId;
        data["makeName"] = this.makeName;
        return data; 
    }

    clone(): ModelRecord {
        const json = this.toJSON();
        let result = new ModelRecord();
        result.init(json);
        return result;
    }
}

export interface IModelRecord {
    id?: number;
    name?: string | undefined;
    makeId?: number | undefined;
    makeName?: string | undefined;
}

export class ModelRequest implements IModelRequest {
    modelRecord?: ModelRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IModelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.modelRecord = data.modelRecord && !(<any>data.modelRecord).toJSON ? new ModelRecord(data.modelRecord) : <ModelRecord>this.modelRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.modelRecord = _data["modelRecord"] ? ModelRecord.fromJS(_data["modelRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ModelRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModelRequest>(data, _mappings, ModelRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelRecord"] = this.modelRecord ? this.modelRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ModelRequest {
        const json = this.toJSON();
        let result = new ModelRequest();
        result.init(json);
        return result;
    }
}

export interface IModelRequest {
    modelRecord?: IModelRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ModelResponse implements IModelResponse {
    data?: ModelRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ModelRecord(item) : <ModelRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ModelRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ModelResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModelResponse>(data, _mappings, ModelResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ModelResponse {
        const json = this.toJSON();
        let result = new ModelResponse();
        result.init(json);
        return result;
    }
}

export interface IModelResponse {
    data?: IModelRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class PlateTypeRecord implements IPlateTypeRecord {
    id?: number;
    name?: string | undefined;

    constructor(data?: IPlateTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlateTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlateTypeRecord>(data, _mappings, PlateTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): PlateTypeRecord {
        const json = this.toJSON();
        let result = new PlateTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IPlateTypeRecord {
    id?: number;
    name?: string | undefined;
}

export class PlateTypeRequest implements IPlateTypeRequest {
    plateTypeRecord?: PlateTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IPlateTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.plateTypeRecord = data.plateTypeRecord && !(<any>data.plateTypeRecord).toJSON ? new PlateTypeRecord(data.plateTypeRecord) : <PlateTypeRecord>this.plateTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.plateTypeRecord = _data["plateTypeRecord"] ? PlateTypeRecord.fromJS(_data["plateTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): PlateTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlateTypeRequest>(data, _mappings, PlateTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plateTypeRecord"] = this.plateTypeRecord ? this.plateTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PlateTypeRequest {
        const json = this.toJSON();
        let result = new PlateTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IPlateTypeRequest {
    plateTypeRecord?: IPlateTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class PlateTypeResponse implements IPlateTypeResponse {
    data?: PlateTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IPlateTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new PlateTypeRecord(item) : <PlateTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(PlateTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlateTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlateTypeResponse>(data, _mappings, PlateTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PlateTypeResponse {
        const json = this.toJSON();
        let result = new PlateTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IPlateTypeResponse {
    data?: IPlateTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ProviderRecord implements IProviderRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;

    constructor(data?: IProviderRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameEn = _data["nameEn"];
            this.nameAr = _data["nameAr"];
            this.typeId = _data["typeId"];
            this.emirateId = _data["emirateId"];
            this.address = _data["address"];
            this.email = _data["email"];
            this.landline = _data["landline"];
            this.mobile = _data["mobile"];
            this.website = _data["website"];
            this.trn = _data["trn"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.emirateName = _data["emirateName"];
            this.typeName = _data["typeName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderRecord>(data, _mappings, ProviderRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameEn"] = this.nameEn;
        data["nameAr"] = this.nameAr;
        data["typeId"] = this.typeId;
        data["emirateId"] = this.emirateId;
        data["address"] = this.address;
        data["email"] = this.email;
        data["landline"] = this.landline;
        data["mobile"] = this.mobile;
        data["website"] = this.website;
        data["trn"] = this.trn;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["emirateName"] = this.emirateName;
        data["typeName"] = this.typeName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data; 
    }

    clone(): ProviderRecord {
        const json = this.toJSON();
        let result = new ProviderRecord();
        result.init(json);
        return result;
    }
}

export interface IProviderRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    typeId?: number | undefined;
    emirateId?: number | undefined;
    address?: string | undefined;
    email?: string | undefined;
    landline?: string | undefined;
    mobile?: string | undefined;
    website?: string | undefined;
    trn?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    typeName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
}

export class ProviderRequest implements IProviderRequest {
    providerRecord?: ProviderRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IProviderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.providerRecord = data.providerRecord && !(<any>data.providerRecord).toJSON ? new ProviderRecord(data.providerRecord) : <ProviderRecord>this.providerRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerRecord = _data["providerRecord"] ? ProviderRecord.fromJS(_data["providerRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderRequest>(data, _mappings, ProviderRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerRecord"] = this.providerRecord ? this.providerRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ProviderRequest {
        const json = this.toJSON();
        let result = new ProviderRequest();
        result.init(json);
        return result;
    }
}

export interface IProviderRequest {
    providerRecord?: IProviderRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ProviderResponse implements IProviderResponse {
    data?: ProviderRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IProviderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ProviderRecord(item) : <ProviderRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ProviderRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderResponse>(data, _mappings, ProviderResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProviderResponse {
        const json = this.toJSON();
        let result = new ProviderResponse();
        result.init(json);
        return result;
    }
}

export interface IProviderResponse {
    data?: IProviderRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ProviderContactRecord implements IProviderContactRecord {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    providerId?: number;
    providerName?: string | undefined;

    constructor(data?: IProviderContactRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.landline = _data["landline"];
            this.isActive = _data["isActive"];
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderContactRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderContactRecord>(data, _mappings, ProviderContactRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["landline"] = this.landline;
        data["isActive"] = this.isActive;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        return data; 
    }

    clone(): ProviderContactRecord {
        const json = this.toJSON();
        let result = new ProviderContactRecord();
        result.init(json);
        return result;
    }
}

export interface IProviderContactRecord {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    providerId?: number;
    providerName?: string | undefined;
}

export class ProviderContactRequest implements IProviderContactRequest {
    providerContactRecord?: ProviderContactRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IProviderContactRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.providerContactRecord = data.providerContactRecord && !(<any>data.providerContactRecord).toJSON ? new ProviderContactRecord(data.providerContactRecord) : <ProviderContactRecord>this.providerContactRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerContactRecord = _data["providerContactRecord"] ? ProviderContactRecord.fromJS(_data["providerContactRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderContactRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderContactRequest>(data, _mappings, ProviderContactRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerContactRecord"] = this.providerContactRecord ? this.providerContactRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ProviderContactRequest {
        const json = this.toJSON();
        let result = new ProviderContactRequest();
        result.init(json);
        return result;
    }
}

export interface IProviderContactRequest {
    providerContactRecord?: IProviderContactRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ProviderContactResponse implements IProviderContactResponse {
    data?: ProviderContactRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IProviderContactResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ProviderContactRecord(item) : <ProviderContactRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ProviderContactRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderContactResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderContactResponse>(data, _mappings, ProviderContactResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProviderContactResponse {
        const json = this.toJSON();
        let result = new ProviderContactResponse();
        result.init(json);
        return result;
    }
}

export interface IProviderContactResponse {
    data?: IProviderContactRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ProviderTypeRecord implements IProviderTypeRecord {
    id?: number;
    name!: string;
    isActive?: boolean | undefined;

    constructor(data?: IProviderTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderTypeRecord>(data, _mappings, ProviderTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProviderTypeRecord {
        const json = this.toJSON();
        let result = new ProviderTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IProviderTypeRecord {
    id?: number;
    name: string;
    isActive?: boolean | undefined;
}

export class ProviderTypeRequest implements IProviderTypeRequest {
    providerTypeRecord?: ProviderTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IProviderTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.providerTypeRecord = data.providerTypeRecord && !(<any>data.providerTypeRecord).toJSON ? new ProviderTypeRecord(data.providerTypeRecord) : <ProviderTypeRecord>this.providerTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerTypeRecord = _data["providerTypeRecord"] ? ProviderTypeRecord.fromJS(_data["providerTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderTypeRequest>(data, _mappings, ProviderTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerTypeRecord"] = this.providerTypeRecord ? this.providerTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ProviderTypeRequest {
        const json = this.toJSON();
        let result = new ProviderTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IProviderTypeRequest {
    providerTypeRecord?: IProviderTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ProviderTypeResponse implements IProviderTypeResponse {
    data?: ProviderTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IProviderTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ProviderTypeRecord(item) : <ProviderTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ProviderTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderTypeResponse>(data, _mappings, ProviderTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProviderTypeResponse {
        const json = this.toJSON();
        let result = new ProviderTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IProviderTypeResponse {
    data?: IProviderTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class UserRecord implements IUserRecord {
    id?: number;
    name!: string;
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;
    roleID!: number;
    roleName?: string | undefined;
    lastLoginDate?: Date;
    phoneNumber!: string;
    isLoggedIn?: boolean | undefined;
    yardId?: number;
    isActive?: boolean | undefined;

    constructor(data?: IUserRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.roleID = _data["roleID"];
            this.roleName = _data["roleName"];
            this.lastLoginDate = _data["lastLoginDate"] ? new Date(_data["lastLoginDate"].toString()) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.isLoggedIn = _data["isLoggedIn"];
            this.yardId = _data["yardId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRecord>(data, _mappings, UserRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["roleID"] = this.roleID;
        data["roleName"] = this.roleName;
        data["lastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["isLoggedIn"] = this.isLoggedIn;
        data["yardId"] = this.yardId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UserRecord {
        const json = this.toJSON();
        let result = new UserRecord();
        result.init(json);
        return result;
    }
}

export interface IUserRecord {
    id?: number;
    name: string;
    email: string;
    password: string;
    confirmPassword?: string | undefined;
    roleID: number;
    roleName?: string | undefined;
    lastLoginDate?: Date;
    phoneNumber: string;
    isLoggedIn?: boolean | undefined;
    yardId?: number;
    isActive?: boolean | undefined;
}

export class UserRequest implements IUserRequest {
    userRecord?: UserRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userRecord = data.userRecord && !(<any>data.userRecord).toJSON ? new UserRecord(data.userRecord) : <UserRecord>this.userRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userRecord = _data["userRecord"] ? UserRecord.fromJS(_data["userRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UserRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRequest>(data, _mappings, UserRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRecord"] = this.userRecord ? this.userRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserRequest {
        const json = this.toJSON();
        let result = new UserRequest();
        result.init(json);
        return result;
    }
}

export interface IUserRequest {
    userRecord?: IUserRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class UserResponse implements IUserResponse {
    data?: UserRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new UserRecord(item) : <UserRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(UserRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserResponse>(data, _mappings, UserResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserResponse {
        const json = this.toJSON();
        let result = new UserResponse();
        result.init(json);
        return result;
    }
}

export interface IUserResponse {
    data?: IUserRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ImageRecord implements IImageRecord {
    id?: number;
    carId?: number | undefined;
    path?: string | undefined;
    imageType?: number;
    fileName?: string | undefined;
    storeId?: number | undefined;
    imageTypeName?: string | undefined;
    imageFile?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IImageRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.carId = _data["carId"];
            this.path = _data["path"];
            this.imageType = _data["imageType"];
            this.fileName = _data["fileName"];
            this.storeId = _data["storeId"];
            this.imageTypeName = _data["imageTypeName"];
            this.imageFile = _data["imageFile"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any, _mappings?: any): ImageRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ImageRecord>(data, _mappings, ImageRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["carId"] = this.carId;
        data["path"] = this.path;
        data["imageType"] = this.imageType;
        data["fileName"] = this.fileName;
        data["storeId"] = this.storeId;
        data["imageTypeName"] = this.imageTypeName;
        data["imageFile"] = this.imageFile;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }

    clone(): ImageRecord {
        const json = this.toJSON();
        let result = new ImageRecord();
        result.init(json);
        return result;
    }
}

export interface IImageRecord {
    id?: number;
    carId?: number | undefined;
    path?: string | undefined;
    imageType?: number;
    fileName?: string | undefined;
    storeId?: number | undefined;
    imageTypeName?: string | undefined;
    imageFile?: string | undefined;
    imageUrl?: string | undefined;
}

export class PlateRecord implements IPlateRecord {
    id?: number;
    emirateId?: number | undefined;
    carId?: number | undefined;
    code?: string | undefined;
    number?: string | undefined;
    plateType?: number;
    plateTypeId?: number | undefined;
    hasPlate?: boolean | undefined;
    plateCodeId?: number | undefined;
    numberOfPlates?: number | undefined;
    isForgery?: boolean;
    plateTypeName?: string | undefined;
    emirateName?: string | undefined;

    constructor(data?: IPlateRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emirateId = _data["emirateId"];
            this.carId = _data["carId"];
            this.code = _data["code"];
            this.number = _data["number"];
            this.plateType = _data["plateType"];
            this.plateTypeId = _data["plateTypeId"];
            this.hasPlate = _data["hasPlate"];
            this.plateCodeId = _data["plateCodeId"];
            this.numberOfPlates = _data["numberOfPlates"];
            this.isForgery = _data["isForgery"];
            this.plateTypeName = _data["plateTypeName"];
            this.emirateName = _data["emirateName"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlateRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlateRecord>(data, _mappings, PlateRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emirateId"] = this.emirateId;
        data["carId"] = this.carId;
        data["code"] = this.code;
        data["number"] = this.number;
        data["plateType"] = this.plateType;
        data["plateTypeId"] = this.plateTypeId;
        data["hasPlate"] = this.hasPlate;
        data["plateCodeId"] = this.plateCodeId;
        data["numberOfPlates"] = this.numberOfPlates;
        data["isForgery"] = this.isForgery;
        data["plateTypeName"] = this.plateTypeName;
        data["emirateName"] = this.emirateName;
        return data; 
    }

    clone(): PlateRecord {
        const json = this.toJSON();
        let result = new PlateRecord();
        result.init(json);
        return result;
    }
}

export interface IPlateRecord {
    id?: number;
    emirateId?: number | undefined;
    carId?: number | undefined;
    code?: string | undefined;
    number?: string | undefined;
    plateType?: number;
    plateTypeId?: number | undefined;
    hasPlate?: boolean | undefined;
    plateCodeId?: number | undefined;
    numberOfPlates?: number | undefined;
    isForgery?: boolean;
    plateTypeName?: string | undefined;
    emirateName?: string | undefined;
}

export class NoVinRationaleRecord implements INoVinRationaleRecord {
    id?: number;
    rationale?: string | undefined;
    vehicleId?: number;

    constructor(data?: INoVinRationaleRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rationale = _data["rationale"];
            this.vehicleId = _data["vehicleId"];
        }
    }

    static fromJS(data: any, _mappings?: any): NoVinRationaleRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<NoVinRationaleRecord>(data, _mappings, NoVinRationaleRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rationale"] = this.rationale;
        data["vehicleId"] = this.vehicleId;
        return data; 
    }

    clone(): NoVinRationaleRecord {
        const json = this.toJSON();
        let result = new NoVinRationaleRecord();
        result.init(json);
        return result;
    }
}

export interface INoVinRationaleRecord {
    id?: number;
    rationale?: string | undefined;
    vehicleId?: number;
}

export class VehicleQrCodeRecord implements IVehicleQrCodeRecord {
    id?: number;
    qrCode?: string | undefined;
    vehicleId?: number;

    constructor(data?: IVehicleQrCodeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.qrCode = _data["qrCode"];
            this.vehicleId = _data["vehicleId"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleQrCodeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleQrCodeRecord>(data, _mappings, VehicleQrCodeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["qrCode"] = this.qrCode;
        data["vehicleId"] = this.vehicleId;
        return data; 
    }

    clone(): VehicleQrCodeRecord {
        const json = this.toJSON();
        let result = new VehicleQrCodeRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleQrCodeRecord {
    id?: number;
    qrCode?: string | undefined;
    vehicleId?: number;
}

export class DocumentRecord implements IDocumentRecord {
    id?: number;
    documentHash?: string | undefined;
    documentName?: string | undefined;
    documentType?: number;
    title?: string | undefined;
    description?: string | undefined;
    documentTypeName?: string | undefined;
    docFile?: string | undefined;
    docUrl?: string | undefined;

    constructor(data?: IDocumentRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentHash = _data["documentHash"];
            this.documentName = _data["documentName"];
            this.documentType = _data["documentType"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.documentTypeName = _data["documentTypeName"];
            this.docFile = _data["docFile"];
            this.docUrl = _data["docUrl"];
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentRecord>(data, _mappings, DocumentRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentHash"] = this.documentHash;
        data["documentName"] = this.documentName;
        data["documentType"] = this.documentType;
        data["title"] = this.title;
        data["description"] = this.description;
        data["documentTypeName"] = this.documentTypeName;
        data["docFile"] = this.docFile;
        data["docUrl"] = this.docUrl;
        return data; 
    }

    clone(): DocumentRecord {
        const json = this.toJSON();
        let result = new DocumentRecord();
        result.init(json);
        return result;
    }
}

export interface IDocumentRecord {
    id?: number;
    documentHash?: string | undefined;
    documentName?: string | undefined;
    documentType?: number;
    title?: string | undefined;
    description?: string | undefined;
    documentTypeName?: string | undefined;
    docFile?: string | undefined;
    docUrl?: string | undefined;
}

export class VehicleRecord implements IVehicleRecord {
    id?: number;
    year?: number | undefined;
    vin?: string | undefined;
    hasVin?: number;
    beneficiaryId?: number | undefined;
    beneficiaryName?: string | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    providerId?: number | undefined;
    providerName?: string | undefined;
    vehicleTypeId?: number | undefined;
    vehicleTypeName?: string | undefined;
    modelId?: number | undefined;
    modelName?: string | undefined;
    makeId?: number | undefined;
    makeName?: string | undefined;
    locked?: boolean | undefined;
    images?: ImageRecord[] | undefined;
    plates?: PlateRecord[] | undefined;
    plateNumberFilter?: string | undefined;
    beneficiaryIdsFilter?: number[] | undefined;
    providerIdsFilter?: number[] | undefined;
    statusIdsFilter?: number[] | undefined;
    vehicleTypeIdsFilter?: number[] | undefined;
    idStrFilter?: string | undefined;
    yardInDate?: Date | undefined;
    dataStatusName?: string | undefined;
    dataStatusId?: number | undefined;
    noVinRationales?: NoVinRationaleRecord[] | undefined;
    qrCodes?: VehicleQrCodeRecord[] | undefined;
    qrCodeFilter?: string | undefined;
    currentQrCode?: string | undefined;
    documents?: DocumentRecord[] | undefined;
    ownershipStartDate?: Date | undefined;
    dataStatusIdsFilter?: number[] | undefined;

    constructor(data?: IVehicleRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.images) {
                this.images = [];
                for (let i = 0; i < data.images.length; i++) {
                    let item = data.images[i];
                    this.images[i] = item && !(<any>item).toJSON ? new ImageRecord(item) : <ImageRecord>item;
                }
            }
            if (data.plates) {
                this.plates = [];
                for (let i = 0; i < data.plates.length; i++) {
                    let item = data.plates[i];
                    this.plates[i] = item && !(<any>item).toJSON ? new PlateRecord(item) : <PlateRecord>item;
                }
            }
            if (data.noVinRationales) {
                this.noVinRationales = [];
                for (let i = 0; i < data.noVinRationales.length; i++) {
                    let item = data.noVinRationales[i];
                    this.noVinRationales[i] = item && !(<any>item).toJSON ? new NoVinRationaleRecord(item) : <NoVinRationaleRecord>item;
                }
            }
            if (data.qrCodes) {
                this.qrCodes = [];
                for (let i = 0; i < data.qrCodes.length; i++) {
                    let item = data.qrCodes[i];
                    this.qrCodes[i] = item && !(<any>item).toJSON ? new VehicleQrCodeRecord(item) : <VehicleQrCodeRecord>item;
                }
            }
            if (data.documents) {
                this.documents = [];
                for (let i = 0; i < data.documents.length; i++) {
                    let item = data.documents[i];
                    this.documents[i] = item && !(<any>item).toJSON ? new DocumentRecord(item) : <DocumentRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.vin = _data["vin"];
            this.hasVin = _data["hasVin"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiaryName = _data["beneficiaryName"];
            this.statusId = _data["statusId"];
            this.statusName = _data["statusName"];
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
            this.vehicleTypeId = _data["vehicleTypeId"];
            this.vehicleTypeName = _data["vehicleTypeName"];
            this.modelId = _data["modelId"];
            this.modelName = _data["modelName"];
            this.makeId = _data["makeId"];
            this.makeName = _data["makeName"];
            this.locked = _data["locked"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ImageRecord.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["plates"])) {
                this.plates = [] as any;
                for (let item of _data["plates"])
                    this.plates!.push(PlateRecord.fromJS(item, _mappings));
            }
            this.plateNumberFilter = _data["plateNumberFilter"];
            if (Array.isArray(_data["beneficiaryIdsFilter"])) {
                this.beneficiaryIdsFilter = [] as any;
                for (let item of _data["beneficiaryIdsFilter"])
                    this.beneficiaryIdsFilter!.push(item);
            }
            if (Array.isArray(_data["providerIdsFilter"])) {
                this.providerIdsFilter = [] as any;
                for (let item of _data["providerIdsFilter"])
                    this.providerIdsFilter!.push(item);
            }
            if (Array.isArray(_data["statusIdsFilter"])) {
                this.statusIdsFilter = [] as any;
                for (let item of _data["statusIdsFilter"])
                    this.statusIdsFilter!.push(item);
            }
            if (Array.isArray(_data["vehicleTypeIdsFilter"])) {
                this.vehicleTypeIdsFilter = [] as any;
                for (let item of _data["vehicleTypeIdsFilter"])
                    this.vehicleTypeIdsFilter!.push(item);
            }
            this.idStrFilter = _data["idStrFilter"];
            this.yardInDate = _data["yardInDate"] ? new Date(_data["yardInDate"].toString()) : <any>undefined;
            this.dataStatusName = _data["dataStatusName"];
            this.dataStatusId = _data["dataStatusId"];
            if (Array.isArray(_data["noVinRationales"])) {
                this.noVinRationales = [] as any;
                for (let item of _data["noVinRationales"])
                    this.noVinRationales!.push(NoVinRationaleRecord.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["qrCodes"])) {
                this.qrCodes = [] as any;
                for (let item of _data["qrCodes"])
                    this.qrCodes!.push(VehicleQrCodeRecord.fromJS(item, _mappings));
            }
            this.qrCodeFilter = _data["qrCodeFilter"];
            this.currentQrCode = _data["currentQrCode"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentRecord.fromJS(item, _mappings));
            }
            this.ownershipStartDate = _data["ownershipStartDate"] ? new Date(_data["ownershipStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["dataStatusIdsFilter"])) {
                this.dataStatusIdsFilter = [] as any;
                for (let item of _data["dataStatusIdsFilter"])
                    this.dataStatusIdsFilter!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleRecord>(data, _mappings, VehicleRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["vin"] = this.vin;
        data["hasVin"] = this.hasVin;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiaryName"] = this.beneficiaryName;
        data["statusId"] = this.statusId;
        data["statusName"] = this.statusName;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        data["vehicleTypeId"] = this.vehicleTypeId;
        data["vehicleTypeName"] = this.vehicleTypeName;
        data["modelId"] = this.modelId;
        data["modelName"] = this.modelName;
        data["makeId"] = this.makeId;
        data["makeName"] = this.makeName;
        data["locked"] = this.locked;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.plates)) {
            data["plates"] = [];
            for (let item of this.plates)
                data["plates"].push(item.toJSON());
        }
        data["plateNumberFilter"] = this.plateNumberFilter;
        if (Array.isArray(this.beneficiaryIdsFilter)) {
            data["beneficiaryIdsFilter"] = [];
            for (let item of this.beneficiaryIdsFilter)
                data["beneficiaryIdsFilter"].push(item);
        }
        if (Array.isArray(this.providerIdsFilter)) {
            data["providerIdsFilter"] = [];
            for (let item of this.providerIdsFilter)
                data["providerIdsFilter"].push(item);
        }
        if (Array.isArray(this.statusIdsFilter)) {
            data["statusIdsFilter"] = [];
            for (let item of this.statusIdsFilter)
                data["statusIdsFilter"].push(item);
        }
        if (Array.isArray(this.vehicleTypeIdsFilter)) {
            data["vehicleTypeIdsFilter"] = [];
            for (let item of this.vehicleTypeIdsFilter)
                data["vehicleTypeIdsFilter"].push(item);
        }
        data["idStrFilter"] = this.idStrFilter;
        data["yardInDate"] = this.yardInDate ? this.yardInDate.toISOString() : <any>undefined;
        data["dataStatusName"] = this.dataStatusName;
        data["dataStatusId"] = this.dataStatusId;
        if (Array.isArray(this.noVinRationales)) {
            data["noVinRationales"] = [];
            for (let item of this.noVinRationales)
                data["noVinRationales"].push(item.toJSON());
        }
        if (Array.isArray(this.qrCodes)) {
            data["qrCodes"] = [];
            for (let item of this.qrCodes)
                data["qrCodes"].push(item.toJSON());
        }
        data["qrCodeFilter"] = this.qrCodeFilter;
        data["currentQrCode"] = this.currentQrCode;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["ownershipStartDate"] = this.ownershipStartDate ? this.ownershipStartDate.toISOString() : <any>undefined;
        if (Array.isArray(this.dataStatusIdsFilter)) {
            data["dataStatusIdsFilter"] = [];
            for (let item of this.dataStatusIdsFilter)
                data["dataStatusIdsFilter"].push(item);
        }
        return data; 
    }

    clone(): VehicleRecord {
        const json = this.toJSON();
        let result = new VehicleRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleRecord {
    id?: number;
    year?: number | undefined;
    vin?: string | undefined;
    hasVin?: number;
    beneficiaryId?: number | undefined;
    beneficiaryName?: string | undefined;
    statusId?: number | undefined;
    statusName?: string | undefined;
    providerId?: number | undefined;
    providerName?: string | undefined;
    vehicleTypeId?: number | undefined;
    vehicleTypeName?: string | undefined;
    modelId?: number | undefined;
    modelName?: string | undefined;
    makeId?: number | undefined;
    makeName?: string | undefined;
    locked?: boolean | undefined;
    images?: IImageRecord[] | undefined;
    plates?: IPlateRecord[] | undefined;
    plateNumberFilter?: string | undefined;
    beneficiaryIdsFilter?: number[] | undefined;
    providerIdsFilter?: number[] | undefined;
    statusIdsFilter?: number[] | undefined;
    vehicleTypeIdsFilter?: number[] | undefined;
    idStrFilter?: string | undefined;
    yardInDate?: Date | undefined;
    dataStatusName?: string | undefined;
    dataStatusId?: number | undefined;
    noVinRationales?: INoVinRationaleRecord[] | undefined;
    qrCodes?: IVehicleQrCodeRecord[] | undefined;
    qrCodeFilter?: string | undefined;
    currentQrCode?: string | undefined;
    documents?: IDocumentRecord[] | undefined;
    ownershipStartDate?: Date | undefined;
    dataStatusIdsFilter?: number[] | undefined;
}

export class VehicleRequest implements IVehicleRequest {
    vehicleRecord?: VehicleRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleRecord = data.vehicleRecord && !(<any>data.vehicleRecord).toJSON ? new VehicleRecord(data.vehicleRecord) : <VehicleRecord>this.vehicleRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleRecord = _data["vehicleRecord"] ? VehicleRecord.fromJS(_data["vehicleRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleRequest>(data, _mappings, VehicleRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleRecord"] = this.vehicleRecord ? this.vehicleRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleRequest {
        const json = this.toJSON();
        let result = new VehicleRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleRequest {
    vehicleRecord?: IVehicleRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleResponse implements IVehicleResponse {
    data?: VehicleRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleRecord(item) : <VehicleRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleResponse>(data, _mappings, VehicleResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleResponse {
        const json = this.toJSON();
        let result = new VehicleResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleResponse {
    data?: IVehicleRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleActionRecord implements IVehicleActionRecord {
    id?: number;
    action!: string;

    constructor(data?: IVehicleActionRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionRecord>(data, _mappings, VehicleActionRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        return data; 
    }

    clone(): VehicleActionRecord {
        const json = this.toJSON();
        let result = new VehicleActionRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionRecord {
    id?: number;
    action: string;
}

export class VehicleActionRequest implements IVehicleActionRequest {
    vehicleActionRecord?: VehicleActionRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleActionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleActionRecord = data.vehicleActionRecord && !(<any>data.vehicleActionRecord).toJSON ? new VehicleActionRecord(data.vehicleActionRecord) : <VehicleActionRecord>this.vehicleActionRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleActionRecord = _data["vehicleActionRecord"] ? VehicleActionRecord.fromJS(_data["vehicleActionRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionRequest>(data, _mappings, VehicleActionRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleActionRecord"] = this.vehicleActionRecord ? this.vehicleActionRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleActionRequest {
        const json = this.toJSON();
        let result = new VehicleActionRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionRequest {
    vehicleActionRecord?: IVehicleActionRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleActionResponse implements IVehicleActionResponse {
    data?: VehicleActionRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleActionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleActionRecord(item) : <VehicleActionRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleActionRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionResponse>(data, _mappings, VehicleActionResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleActionResponse {
        const json = this.toJSON();
        let result = new VehicleActionResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionResponse {
    data?: IVehicleActionRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleActionHistoryRecord implements IVehicleActionHistoryRecord {
    id?: number;
    vehicleId?: number;
    actionId?: number;
    actionDate?: Date;
    userId?: string | undefined;
    notes?: string | undefined;
    actionName?: string | undefined;

    constructor(data?: IVehicleActionHistoryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleId = _data["vehicleId"];
            this.actionId = _data["actionId"];
            this.actionDate = _data["actionDate"] ? new Date(_data["actionDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.notes = _data["notes"];
            this.actionName = _data["actionName"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionHistoryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionHistoryRecord>(data, _mappings, VehicleActionHistoryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleId"] = this.vehicleId;
        data["actionId"] = this.actionId;
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["notes"] = this.notes;
        data["actionName"] = this.actionName;
        return data; 
    }

    clone(): VehicleActionHistoryRecord {
        const json = this.toJSON();
        let result = new VehicleActionHistoryRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionHistoryRecord {
    id?: number;
    vehicleId?: number;
    actionId?: number;
    actionDate?: Date;
    userId?: string | undefined;
    notes?: string | undefined;
    actionName?: string | undefined;
}

export class VehicleActionHistoryRequest implements IVehicleActionHistoryRequest {
    vehicleActionHistoryRecord?: VehicleActionHistoryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleActionHistoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleActionHistoryRecord = data.vehicleActionHistoryRecord && !(<any>data.vehicleActionHistoryRecord).toJSON ? new VehicleActionHistoryRecord(data.vehicleActionHistoryRecord) : <VehicleActionHistoryRecord>this.vehicleActionHistoryRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleActionHistoryRecord = _data["vehicleActionHistoryRecord"] ? VehicleActionHistoryRecord.fromJS(_data["vehicleActionHistoryRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionHistoryRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionHistoryRequest>(data, _mappings, VehicleActionHistoryRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleActionHistoryRecord"] = this.vehicleActionHistoryRecord ? this.vehicleActionHistoryRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleActionHistoryRequest {
        const json = this.toJSON();
        let result = new VehicleActionHistoryRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionHistoryRequest {
    vehicleActionHistoryRecord?: IVehicleActionHistoryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleActionHistoryResponse implements IVehicleActionHistoryResponse {
    data?: VehicleActionHistoryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleActionHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleActionHistoryRecord(item) : <VehicleActionHistoryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleActionHistoryRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleActionHistoryResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleActionHistoryResponse>(data, _mappings, VehicleActionHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleActionHistoryResponse {
        const json = this.toJSON();
        let result = new VehicleActionHistoryResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleActionHistoryResponse {
    data?: IVehicleActionHistoryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleDataStatusRecord implements IVehicleDataStatusRecord {
    id?: number;
    name!: string;

    constructor(data?: IVehicleDataStatusRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleDataStatusRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleDataStatusRecord>(data, _mappings, VehicleDataStatusRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): VehicleDataStatusRecord {
        const json = this.toJSON();
        let result = new VehicleDataStatusRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleDataStatusRecord {
    id?: number;
    name: string;
}

export class VehicleDataStatusRequest implements IVehicleDataStatusRequest {
    vehicleDataStatusRecord?: VehicleDataStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleDataStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleDataStatusRecord = data.vehicleDataStatusRecord && !(<any>data.vehicleDataStatusRecord).toJSON ? new VehicleDataStatusRecord(data.vehicleDataStatusRecord) : <VehicleDataStatusRecord>this.vehicleDataStatusRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleDataStatusRecord = _data["vehicleDataStatusRecord"] ? VehicleDataStatusRecord.fromJS(_data["vehicleDataStatusRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleDataStatusRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleDataStatusRequest>(data, _mappings, VehicleDataStatusRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleDataStatusRecord"] = this.vehicleDataStatusRecord ? this.vehicleDataStatusRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleDataStatusRequest {
        const json = this.toJSON();
        let result = new VehicleDataStatusRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleDataStatusRequest {
    vehicleDataStatusRecord?: IVehicleDataStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleDataStatusResponse implements IVehicleDataStatusResponse {
    data?: VehicleDataStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleDataStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleDataStatusRecord(item) : <VehicleDataStatusRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleDataStatusRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleDataStatusResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleDataStatusResponse>(data, _mappings, VehicleDataStatusResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleDataStatusResponse {
        const json = this.toJSON();
        let result = new VehicleDataStatusResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleDataStatusResponse {
    data?: IVehicleDataStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleOwnershipHistoryRecord implements IVehicleOwnershipHistoryRecord {
    id?: number;
    qrCode?: string | undefined;
    vehicleId?: number;
    beneficiaryId?: number | undefined;
    providerId?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    notes?: string | undefined;
    beneficiaryName?: string | undefined;
    providerName?: string | undefined;

    constructor(data?: IVehicleOwnershipHistoryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.qrCode = _data["qrCode"];
            this.vehicleId = _data["vehicleId"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.providerId = _data["providerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.beneficiaryName = _data["beneficiaryName"];
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleOwnershipHistoryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleOwnershipHistoryRecord>(data, _mappings, VehicleOwnershipHistoryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["qrCode"] = this.qrCode;
        data["vehicleId"] = this.vehicleId;
        data["beneficiaryId"] = this.beneficiaryId;
        data["providerId"] = this.providerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["beneficiaryName"] = this.beneficiaryName;
        data["providerName"] = this.providerName;
        return data; 
    }

    clone(): VehicleOwnershipHistoryRecord {
        const json = this.toJSON();
        let result = new VehicleOwnershipHistoryRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleOwnershipHistoryRecord {
    id?: number;
    qrCode?: string | undefined;
    vehicleId?: number;
    beneficiaryId?: number | undefined;
    providerId?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    notes?: string | undefined;
    beneficiaryName?: string | undefined;
    providerName?: string | undefined;
}

export class VehicleOwnershipHistoryRequest implements IVehicleOwnershipHistoryRequest {
    vehicleOwnershipHistoryRecord?: VehicleOwnershipHistoryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleOwnershipHistoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleOwnershipHistoryRecord = data.vehicleOwnershipHistoryRecord && !(<any>data.vehicleOwnershipHistoryRecord).toJSON ? new VehicleOwnershipHistoryRecord(data.vehicleOwnershipHistoryRecord) : <VehicleOwnershipHistoryRecord>this.vehicleOwnershipHistoryRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleOwnershipHistoryRecord = _data["vehicleOwnershipHistoryRecord"] ? VehicleOwnershipHistoryRecord.fromJS(_data["vehicleOwnershipHistoryRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleOwnershipHistoryRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleOwnershipHistoryRequest>(data, _mappings, VehicleOwnershipHistoryRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleOwnershipHistoryRecord"] = this.vehicleOwnershipHistoryRecord ? this.vehicleOwnershipHistoryRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleOwnershipHistoryRequest {
        const json = this.toJSON();
        let result = new VehicleOwnershipHistoryRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleOwnershipHistoryRequest {
    vehicleOwnershipHistoryRecord?: IVehicleOwnershipHistoryRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleOwnershipHistoryResponse implements IVehicleOwnershipHistoryResponse {
    data?: VehicleOwnershipHistoryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleOwnershipHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleOwnershipHistoryRecord(item) : <VehicleOwnershipHistoryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleOwnershipHistoryRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleOwnershipHistoryResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleOwnershipHistoryResponse>(data, _mappings, VehicleOwnershipHistoryResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleOwnershipHistoryResponse {
        const json = this.toJSON();
        let result = new VehicleOwnershipHistoryResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleOwnershipHistoryResponse {
    data?: IVehicleOwnershipHistoryRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleStatusRecord implements IVehicleStatusRecord {
    id?: number;
    title!: string;

    constructor(data?: IVehicleStatusRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleStatusRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleStatusRecord>(data, _mappings, VehicleStatusRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }

    clone(): VehicleStatusRecord {
        const json = this.toJSON();
        let result = new VehicleStatusRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleStatusRecord {
    id?: number;
    title: string;
}

export class VehicleStatusRequest implements IVehicleStatusRequest {
    vehicleStatusRecord?: VehicleStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleStatusRecord = data.vehicleStatusRecord && !(<any>data.vehicleStatusRecord).toJSON ? new VehicleStatusRecord(data.vehicleStatusRecord) : <VehicleStatusRecord>this.vehicleStatusRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleStatusRecord = _data["vehicleStatusRecord"] ? VehicleStatusRecord.fromJS(_data["vehicleStatusRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleStatusRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleStatusRequest>(data, _mappings, VehicleStatusRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleStatusRecord"] = this.vehicleStatusRecord ? this.vehicleStatusRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleStatusRequest {
        const json = this.toJSON();
        let result = new VehicleStatusRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleStatusRequest {
    vehicleStatusRecord?: IVehicleStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleStatusResponse implements IVehicleStatusResponse {
    data?: VehicleStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleStatusRecord(item) : <VehicleStatusRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleStatusRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleStatusResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleStatusResponse>(data, _mappings, VehicleStatusResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleStatusResponse {
        const json = this.toJSON();
        let result = new VehicleStatusResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleStatusResponse {
    data?: IVehicleStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class VehicleTypeRecord implements IVehicleTypeRecord {
    id?: number;
    name?: string | undefined;
    nameAr?: string | undefined;
    hasVin?: boolean | undefined;
    nameEn?: string | undefined;

    constructor(data?: IVehicleTypeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nameAr = _data["nameAr"];
            this.hasVin = _data["hasVin"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleTypeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleTypeRecord>(data, _mappings, VehicleTypeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nameAr"] = this.nameAr;
        data["hasVin"] = this.hasVin;
        data["nameEn"] = this.nameEn;
        return data; 
    }

    clone(): VehicleTypeRecord {
        const json = this.toJSON();
        let result = new VehicleTypeRecord();
        result.init(json);
        return result;
    }
}

export interface IVehicleTypeRecord {
    id?: number;
    name?: string | undefined;
    nameAr?: string | undefined;
    hasVin?: boolean | undefined;
    nameEn?: string | undefined;
}

export class VehicleTypeRequest implements IVehicleTypeRequest {
    vehicleTypeRecord?: VehicleTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IVehicleTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.vehicleTypeRecord = data.vehicleTypeRecord && !(<any>data.vehicleTypeRecord).toJSON ? new VehicleTypeRecord(data.vehicleTypeRecord) : <VehicleTypeRecord>this.vehicleTypeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.vehicleTypeRecord = _data["vehicleTypeRecord"] ? VehicleTypeRecord.fromJS(_data["vehicleTypeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleTypeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleTypeRequest>(data, _mappings, VehicleTypeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleTypeRecord"] = this.vehicleTypeRecord ? this.vehicleTypeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VehicleTypeRequest {
        const json = this.toJSON();
        let result = new VehicleTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IVehicleTypeRequest {
    vehicleTypeRecord?: IVehicleTypeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class VehicleTypeResponse implements IVehicleTypeResponse {
    data?: VehicleTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IVehicleTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VehicleTypeRecord(item) : <VehicleTypeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(VehicleTypeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): VehicleTypeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<VehicleTypeResponse>(data, _mappings, VehicleTypeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VehicleTypeResponse {
        const json = this.toJSON();
        let result = new VehicleTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IVehicleTypeResponse {
    data?: IVehicleTypeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class YardBoundaryRecord implements IYardBoundaryRecord {
    latitude?: number;
    longitude?: number;

    constructor(data?: IYardBoundaryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardBoundaryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardBoundaryRecord>(data, _mappings, YardBoundaryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }

    clone(): YardBoundaryRecord {
        const json = this.toJSON();
        let result = new YardBoundaryRecord();
        result.init(json);
        return result;
    }
}

export interface IYardBoundaryRecord {
    latitude?: number;
    longitude?: number;
}

export class YardRecord implements IYardRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    gy?: string | undefined;
    gx?: string | undefined;
    distance?: number;
    yardType?: number;
    emirateId?: number;
    maxFee?: number | undefined;
    moveToAuctionPeriod?: number | undefined;
    statusId?: number | undefined;
    capacity?: number | undefined;
    thresholdCapacity?: number | undefined;
    workingFrom?: string | undefined;
    workingTo?: string | undefined;
    statusName?: string | undefined;
    yardBoundaries?: YardBoundaryRecord[] | undefined;
    yardId?: number;
    area?: string | undefined;
    zoom?: number | undefined;

    constructor(data?: IYardRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.yardBoundaries) {
                this.yardBoundaries = [];
                for (let i = 0; i < data.yardBoundaries.length; i++) {
                    let item = data.yardBoundaries[i];
                    this.yardBoundaries[i] = item && !(<any>item).toJSON ? new YardBoundaryRecord(item) : <YardBoundaryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameEn = _data["nameEn"];
            this.nameAr = _data["nameAr"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.emirateName = _data["emirateName"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.gy = _data["gy"];
            this.gx = _data["gx"];
            this.distance = _data["distance"];
            this.yardType = _data["yardType"];
            this.emirateId = _data["emirateId"];
            this.maxFee = _data["maxFee"];
            this.moveToAuctionPeriod = _data["moveToAuctionPeriod"];
            this.statusId = _data["statusId"];
            this.capacity = _data["capacity"];
            this.thresholdCapacity = _data["thresholdCapacity"];
            this.workingFrom = _data["workingFrom"];
            this.workingTo = _data["workingTo"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["yardBoundaries"])) {
                this.yardBoundaries = [] as any;
                for (let item of _data["yardBoundaries"])
                    this.yardBoundaries!.push(YardBoundaryRecord.fromJS(item, _mappings));
            }
            this.yardId = _data["yardId"];
            this.area = _data["area"];
            this.zoom = _data["zoom"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardRecord>(data, _mappings, YardRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameEn"] = this.nameEn;
        data["nameAr"] = this.nameAr;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["emirateName"] = this.emirateName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["gy"] = this.gy;
        data["gx"] = this.gx;
        data["distance"] = this.distance;
        data["yardType"] = this.yardType;
        data["emirateId"] = this.emirateId;
        data["maxFee"] = this.maxFee;
        data["moveToAuctionPeriod"] = this.moveToAuctionPeriod;
        data["statusId"] = this.statusId;
        data["capacity"] = this.capacity;
        data["thresholdCapacity"] = this.thresholdCapacity;
        data["workingFrom"] = this.workingFrom;
        data["workingTo"] = this.workingTo;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.yardBoundaries)) {
            data["yardBoundaries"] = [];
            for (let item of this.yardBoundaries)
                data["yardBoundaries"].push(item.toJSON());
        }
        data["yardId"] = this.yardId;
        data["area"] = this.area;
        data["zoom"] = this.zoom;
        return data; 
    }

    clone(): YardRecord {
        const json = this.toJSON();
        let result = new YardRecord();
        result.init(json);
        return result;
    }
}

export interface IYardRecord {
    id?: number;
    nameEn?: string | undefined;
    nameAr?: string | undefined;
    isActive?: boolean | undefined;
    name?: string | undefined;
    emirateName?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    gy?: string | undefined;
    gx?: string | undefined;
    distance?: number;
    yardType?: number;
    emirateId?: number;
    maxFee?: number | undefined;
    moveToAuctionPeriod?: number | undefined;
    statusId?: number | undefined;
    capacity?: number | undefined;
    thresholdCapacity?: number | undefined;
    workingFrom?: string | undefined;
    workingTo?: string | undefined;
    statusName?: string | undefined;
    yardBoundaries?: IYardBoundaryRecord[] | undefined;
    yardId?: number;
    area?: string | undefined;
    zoom?: number | undefined;
}

export class YardRequest implements IYardRequest {
    yardRecord?: YardRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IYardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.yardRecord = data.yardRecord && !(<any>data.yardRecord).toJSON ? new YardRecord(data.yardRecord) : <YardRecord>this.yardRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.yardRecord = _data["yardRecord"] ? YardRecord.fromJS(_data["yardRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): YardRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardRequest>(data, _mappings, YardRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yardRecord"] = this.yardRecord ? this.yardRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): YardRequest {
        const json = this.toJSON();
        let result = new YardRequest();
        result.init(json);
        return result;
    }
}

export interface IYardRequest {
    yardRecord?: IYardRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class YardResponse implements IYardResponse {
    data?: YardRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IYardResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new YardRecord(item) : <YardRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(YardRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardResponse>(data, _mappings, YardResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): YardResponse {
        const json = this.toJSON();
        let result = new YardResponse();
        result.init(json);
        return result;
    }
}

export interface IYardResponse {
    data?: IYardRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class YardEmployeeRecord implements IYardEmployeeRecord {
    id?: number;
    name?: string | undefined;
    position?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    yardId?: number;
    yardName?: string | undefined;

    constructor(data?: IYardEmployeeRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.position = _data["position"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.landline = _data["landline"];
            this.isActive = _data["isActive"];
            this.yardId = _data["yardId"];
            this.yardName = _data["yardName"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardEmployeeRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardEmployeeRecord>(data, _mappings, YardEmployeeRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["position"] = this.position;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["landline"] = this.landline;
        data["isActive"] = this.isActive;
        data["yardId"] = this.yardId;
        data["yardName"] = this.yardName;
        return data; 
    }

    clone(): YardEmployeeRecord {
        const json = this.toJSON();
        let result = new YardEmployeeRecord();
        result.init(json);
        return result;
    }
}

export interface IYardEmployeeRecord {
    id?: number;
    name?: string | undefined;
    position?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    landline?: string | undefined;
    isActive?: boolean | undefined;
    yardId?: number;
    yardName?: string | undefined;
}

export class YardEmployeeRequest implements IYardEmployeeRequest {
    yardEmployeeRecord?: YardEmployeeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IYardEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.yardEmployeeRecord = data.yardEmployeeRecord && !(<any>data.yardEmployeeRecord).toJSON ? new YardEmployeeRecord(data.yardEmployeeRecord) : <YardEmployeeRecord>this.yardEmployeeRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.yardEmployeeRecord = _data["yardEmployeeRecord"] ? YardEmployeeRecord.fromJS(_data["yardEmployeeRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): YardEmployeeRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardEmployeeRequest>(data, _mappings, YardEmployeeRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yardEmployeeRecord"] = this.yardEmployeeRecord ? this.yardEmployeeRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): YardEmployeeRequest {
        const json = this.toJSON();
        let result = new YardEmployeeRequest();
        result.init(json);
        return result;
    }
}

export interface IYardEmployeeRequest {
    yardEmployeeRecord?: IYardEmployeeRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class YardEmployeeResponse implements IYardEmployeeResponse {
    data?: YardEmployeeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IYardEmployeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new YardEmployeeRecord(item) : <YardEmployeeRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(YardEmployeeRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardEmployeeResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardEmployeeResponse>(data, _mappings, YardEmployeeResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): YardEmployeeResponse {
        const json = this.toJSON();
        let result = new YardEmployeeResponse();
        result.init(json);
        return result;
    }
}

export interface IYardEmployeeResponse {
    data?: IYardEmployeeRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class YardStatusRecord implements IYardStatusRecord {
    id?: number;
    name!: string;

    constructor(data?: IYardStatusRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardStatusRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardStatusRecord>(data, _mappings, YardStatusRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): YardStatusRecord {
        const json = this.toJSON();
        let result = new YardStatusRecord();
        result.init(json);
        return result;
    }
}

export interface IYardStatusRecord {
    id?: number;
    name: string;
}

export class YardStatusRequest implements IYardStatusRequest {
    yardStatusRecord?: YardStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IYardStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.yardStatusRecord = data.yardStatusRecord && !(<any>data.yardStatusRecord).toJSON ? new YardStatusRecord(data.yardStatusRecord) : <YardStatusRecord>this.yardStatusRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.yardStatusRecord = _data["yardStatusRecord"] ? YardStatusRecord.fromJS(_data["yardStatusRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): YardStatusRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardStatusRequest>(data, _mappings, YardStatusRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yardStatusRecord"] = this.yardStatusRecord ? this.yardStatusRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): YardStatusRequest {
        const json = this.toJSON();
        let result = new YardStatusRequest();
        result.init(json);
        return result;
    }
}

export interface IYardStatusRequest {
    yardStatusRecord?: IYardStatusRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class YardStatusResponse implements IYardStatusResponse {
    data?: YardStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IYardStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new YardStatusRecord(item) : <YardStatusRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(YardStatusRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): YardStatusResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<YardStatusResponse>(data, _mappings, YardStatusResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): YardStatusResponse {
        const json = this.toJSON();
        let result = new YardStatusResponse();
        result.init(json);
        return result;
    }
}

export interface IYardStatusResponse {
    data?: IYardStatusRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

export class ZoneProviderRecord implements IZoneProviderRecord {
    providerId?: number;
    providerName?: string | undefined;

    constructor(data?: IZoneProviderRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneProviderRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneProviderRecord>(data, _mappings, ZoneProviderRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        return data; 
    }

    clone(): ZoneProviderRecord {
        const json = this.toJSON();
        let result = new ZoneProviderRecord();
        result.init(json);
        return result;
    }
}

export interface IZoneProviderRecord {
    providerId?: number;
    providerName?: string | undefined;
}

export class ZoneBeneficiaryRecord implements IZoneBeneficiaryRecord {
    beneficiaryId?: number;
    beneficiaryName?: string | undefined;

    constructor(data?: IZoneBeneficiaryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiaryName = _data["beneficiaryName"];
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneBeneficiaryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneBeneficiaryRecord>(data, _mappings, ZoneBeneficiaryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiaryName"] = this.beneficiaryName;
        return data; 
    }

    clone(): ZoneBeneficiaryRecord {
        const json = this.toJSON();
        let result = new ZoneBeneficiaryRecord();
        result.init(json);
        return result;
    }
}

export interface IZoneBeneficiaryRecord {
    beneficiaryId?: number;
    beneficiaryName?: string | undefined;
}

export class ZoneBoundaryRecord implements IZoneBoundaryRecord {
    latitude?: number;
    longitude?: number;

    constructor(data?: IZoneBoundaryRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneBoundaryRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneBoundaryRecord>(data, _mappings, ZoneBoundaryRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }

    clone(): ZoneBoundaryRecord {
        const json = this.toJSON();
        let result = new ZoneBoundaryRecord();
        result.init(json);
        return result;
    }
}

export interface IZoneBoundaryRecord {
    latitude?: number;
    longitude?: number;
}

export class ZoneRecord implements IZoneRecord {
    id?: number;
    title?: string | undefined;
    capacity?: number;
    yardId?: number;
    isActive?: boolean | undefined;
    yardName?: string | undefined;
    zoneProviders?: ZoneProviderRecord[] | undefined;
    zoneBeneficiarys?: ZoneBeneficiaryRecord[] | undefined;
    zoneBoundaries?: ZoneBoundaryRecord[] | undefined;
    zoom?: number | undefined;

    constructor(data?: IZoneRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.zoneProviders) {
                this.zoneProviders = [];
                for (let i = 0; i < data.zoneProviders.length; i++) {
                    let item = data.zoneProviders[i];
                    this.zoneProviders[i] = item && !(<any>item).toJSON ? new ZoneProviderRecord(item) : <ZoneProviderRecord>item;
                }
            }
            if (data.zoneBeneficiarys) {
                this.zoneBeneficiarys = [];
                for (let i = 0; i < data.zoneBeneficiarys.length; i++) {
                    let item = data.zoneBeneficiarys[i];
                    this.zoneBeneficiarys[i] = item && !(<any>item).toJSON ? new ZoneBeneficiaryRecord(item) : <ZoneBeneficiaryRecord>item;
                }
            }
            if (data.zoneBoundaries) {
                this.zoneBoundaries = [];
                for (let i = 0; i < data.zoneBoundaries.length; i++) {
                    let item = data.zoneBoundaries[i];
                    this.zoneBoundaries[i] = item && !(<any>item).toJSON ? new ZoneBoundaryRecord(item) : <ZoneBoundaryRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.capacity = _data["capacity"];
            this.yardId = _data["yardId"];
            this.isActive = _data["isActive"];
            this.yardName = _data["yardName"];
            if (Array.isArray(_data["zoneProviders"])) {
                this.zoneProviders = [] as any;
                for (let item of _data["zoneProviders"])
                    this.zoneProviders!.push(ZoneProviderRecord.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["zoneBeneficiarys"])) {
                this.zoneBeneficiarys = [] as any;
                for (let item of _data["zoneBeneficiarys"])
                    this.zoneBeneficiarys!.push(ZoneBeneficiaryRecord.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["zoneBoundaries"])) {
                this.zoneBoundaries = [] as any;
                for (let item of _data["zoneBoundaries"])
                    this.zoneBoundaries!.push(ZoneBoundaryRecord.fromJS(item, _mappings));
            }
            this.zoom = _data["zoom"];
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneRecord {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneRecord>(data, _mappings, ZoneRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["capacity"] = this.capacity;
        data["yardId"] = this.yardId;
        data["isActive"] = this.isActive;
        data["yardName"] = this.yardName;
        if (Array.isArray(this.zoneProviders)) {
            data["zoneProviders"] = [];
            for (let item of this.zoneProviders)
                data["zoneProviders"].push(item.toJSON());
        }
        if (Array.isArray(this.zoneBeneficiarys)) {
            data["zoneBeneficiarys"] = [];
            for (let item of this.zoneBeneficiarys)
                data["zoneBeneficiarys"].push(item.toJSON());
        }
        if (Array.isArray(this.zoneBoundaries)) {
            data["zoneBoundaries"] = [];
            for (let item of this.zoneBoundaries)
                data["zoneBoundaries"].push(item.toJSON());
        }
        data["zoom"] = this.zoom;
        return data; 
    }

    clone(): ZoneRecord {
        const json = this.toJSON();
        let result = new ZoneRecord();
        result.init(json);
        return result;
    }
}

export interface IZoneRecord {
    id?: number;
    title?: string | undefined;
    capacity?: number;
    yardId?: number;
    isActive?: boolean | undefined;
    yardName?: string | undefined;
    zoneProviders?: IZoneProviderRecord[] | undefined;
    zoneBeneficiarys?: IZoneBeneficiaryRecord[] | undefined;
    zoneBoundaries?: IZoneBoundaryRecord[] | undefined;
    zoom?: number | undefined;
}

export class ZoneRequest implements IZoneRequest {
    zoneRecord?: ZoneRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: MailSender;

    constructor(data?: IZoneRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.zoneRecord = data.zoneRecord && !(<any>data.zoneRecord).toJSON ? new ZoneRecord(data.zoneRecord) : <ZoneRecord>this.zoneRecord; 
            this.mailSender = data.mailSender && !(<any>data.mailSender).toJSON ? new MailSender(data.mailSender) : <MailSender>this.mailSender; 
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.zoneRecord = _data["zoneRecord"] ? ZoneRecord.fromJS(_data["zoneRecord"], _mappings) : <any>undefined;
            this.isDesc = _data["isDesc"];
            this.orderByColumn = _data["orderByColumn"];
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.createdBy = _data["createdBy"];
            this.roleID = _data["roleID"];
            this.languageId = _data["languageId"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.mailSender = _data["mailSender"] ? MailSender.fromJS(_data["mailSender"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneRequest {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneRequest>(data, _mappings, ZoneRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneRecord"] = this.zoneRecord ? this.zoneRecord.toJSON() : <any>undefined;
        data["isDesc"] = this.isDesc;
        data["orderByColumn"] = this.orderByColumn;
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["createdBy"] = this.createdBy;
        data["roleID"] = this.roleID;
        data["languageId"] = this.languageId;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["mailSender"] = this.mailSender ? this.mailSender.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ZoneRequest {
        const json = this.toJSON();
        let result = new ZoneRequest();
        result.init(json);
        return result;
    }
}

export interface IZoneRequest {
    zoneRecord?: IZoneRecord;
    isDesc?: boolean;
    orderByColumn?: string | undefined;
    pageSize?: number;
    pageIndex?: number;
    createdBy?: number;
    roleID?: number;
    languageId?: number;
    baseUrl?: string | undefined;
    name?: string | undefined;
    mailSender?: IMailSender;
}

export class ZoneResponse implements IZoneResponse {
    data?: ZoneRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;

    constructor(data?: IZoneResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ZoneRecord(item) : <ZoneRecord>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(ZoneRecord.fromJS(item, _mappings));
            }
            this.message = _data["message"];
            this.success = _data["success"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): ZoneResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<ZoneResponse>(data, _mappings, ZoneResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["success"] = this.success;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ZoneResponse {
        const json = this.toJSON();
        let result = new ZoneResponse();
        result.init(json);
        return result;
    }
}

export interface IZoneResponse {
    data?: IZoneRecord[] | undefined;
    message?: string | undefined;
    success?: boolean;
    totalCount?: number;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}